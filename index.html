<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fence Designer Pro — SecureWorks WA</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 400;
      background: #f8fafc;
    }

    /* Section 0: Branding */
    .header {
      background: #293C46;
      color: #FFFFFF;
      padding: 12px 20px;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
    }

    .header-brand {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 700;
      font-size: 16px;
      margin-right: 8px;
      white-space: nowrap;
    }

    .header-group {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .header-group label {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 700;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      opacity: 0.85;
    }

    .header-group input,
    .header-group select {
      padding: 5px 8px;
      border: 1px solid #4C6A70;
      border-radius: 4px;
      font-size: 13px;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    }

    .header-group input {
      min-width: 100px;
    }

    .header-group select {
      min-width: 120px;
    }

    .header-actions {
      margin-left: auto;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .header-actions .saved-indicator {
      font-size: 12px;
      opacity: 0.7;
    }

    .btn-header {
      padding: 6px 14px;
      background: #F15A29;
      color: #FFFFFF;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 700;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    }

    .btn-header:hover {
      background: #d94e22;
    }

    /* Main Layout */
    .main {
      display: flex;
      height: calc(100vh - 72px);
    }

    .left-panel {
      width: 40%;
      min-width: 450px;
      background: #FFFFFF;
      overflow-y: auto;
      border-right: 1px solid #4C6A70;
    }

    .right-panel {
      width: 60%;
      background: #f8fafc;
      display: flex;
      flex-direction: column;
    }

    /* Run Tabs */
    .run-tabs {
      display: flex;
      background: #F5F5F5;
      border-bottom: 2px solid #4C6A70;
      padding: 8px 8px 0 8px;
      gap: 4px;
      flex-wrap: wrap;
    }

    .run-tab {
      padding: 8px 16px;
      background: #e5e7eb;
      border: 1px solid #4C6A70;
      border-bottom: none;
      border-radius: 4px 4px 0 0;
      cursor: pointer;
      font-size: 13px;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 400;
      color: #4C6A70;
    }

    .run-tab.active {
      background: #FFFFFF;
      font-weight: 700;
      color: #293C46;
      border-bottom: 2px solid #FFFFFF;
      margin-bottom: -2px;
      border-left-color: #F15A29;
      border-top: 2px solid #F15A29;
      border-right-color: #F15A29;
    }

    .run-tab:not(.active):hover {
      background: #d1d5db;
    }

    .add-run-btn {
      padding: 8px 16px;
      background: transparent;
      color: #F15A29;
      border: 2px dashed #F15A29;
      border-bottom: none;
      border-radius: 4px 4px 0 0;
      cursor: pointer;
      font-size: 13px;
      font-weight: 700;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    }

    .add-run-btn:hover {
      background: rgba(241, 90, 41, 0.08);
    }

    /* Run Content */
    .run-content {
      padding: 16px;
    }

    .run-settings {
      background: #F5F5F5;
      padding: 14px;
      border-radius: 4px;
      margin-bottom: 16px;
      border: 1px solid #4C6A70;
    }

    .run-settings h3 {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 700;
      font-size: 13px;
      margin-bottom: 10px;
      color: #293C46;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .run-settings-grid {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
    }

    .run-settings-actions {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .form-group {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .form-group label {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 700;
      font-size: 11px;
      color: #4C6A70;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .form-group input,
    .form-group select {
      padding: 5px 8px;
      border: 1px solid #4C6A70;
      border-radius: 4px;
      font-size: 13px;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    }

    .form-group input:focus,
    .form-group select:focus {
      outline: none;
      border-color: #F15A29;
      box-shadow: 0 0 0 2px rgba(241, 90, 41, 0.15);
    }

    .btn-orange {
      padding: 6px 14px;
      background: #F15A29;
      color: #FFFFFF;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 700;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    }

    .btn-orange:hover {
      background: #d94e22;
    }

    .btn-delete {
      padding: 6px 14px;
      background: transparent;
      color: #dc2626;
      border: none;
      cursor: pointer;
      font-size: 13px;
      font-weight: 700;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    }

    .btn-delete:hover {
      text-decoration: underline;
    }

    /* Ground Slope Section */
    .slope-section {
      background: #f5f0ea;
      border: 1px solid #8B7355;
      padding: 14px;
      border-radius: 4px;
      margin-bottom: 16px;
    }

    .slope-section h3 {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 700;
      font-size: 13px;
      margin-bottom: 6px;
      color: #6B5335;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .slope-hint {
      font-size: 11px;
      color: #8B7355;
      margin-bottom: 10px;
      line-height: 1.4;
    }

    .slope-point-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-bottom: 10px;
    }

    .slope-point-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: #293C46;
    }

    .slope-point-row.slope-point-start {
      color: #999;
    }

    /* Simple/Advanced mode toggle */
    .slope-simple-controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 10px;
    }
    .slope-control-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: #293C46;
    }
    .slope-control-row label {
      font-weight: 700;
      font-size: 11px;
      text-transform: uppercase;
      color: #6B5335;
      min-width: 70px;
      letter-spacing: 0.3px;
    }
    .slope-direction-toggle {
      display: inline-flex;
      border: 1px solid #8B7355;
      border-radius: 4px;
      overflow: hidden;
    }
    .slope-direction-btn {
      padding: 4px 10px;
      border: none;
      background: #f5f0ea;
      color: #6B5335;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      transition: background 0.15s, color 0.15s;
    }
    .slope-direction-btn:not(:last-child) {
      border-right: 1px solid #8B7355;
    }
    .slope-direction-btn.active {
      background: #8B7355;
      color: #fff;
    }
    .slope-direction-btn:hover:not(.active) {
      background: #e8dfd4;
    }
    .slope-fall-input-simple {
      width: 70px;
      padding: 3px 6px;
      border: 1px solid #8B7355;
      border-radius: 3px;
      font-size: 12px;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      text-align: center;
    }
    .slope-fall-input-simple:focus {
      outline: none;
      border-color: #6B5335;
      box-shadow: 0 0 0 2px rgba(139,115,85,0.2);
    }
    .slope-starts-select {
      padding: 3px 6px;
      border: 1px solid #8B7355;
      border-radius: 3px;
      font-size: 12px;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      background: #fff;
    }
    .slope-starts-select:focus {
      outline: none;
      border-color: #6B5335;
      box-shadow: 0 0 0 2px rgba(139,115,85,0.2);
    }
    .slope-helper-label {
      font-size: 11px;
      color: #8B7355;
      font-style: italic;
      margin-top: -4px;
      padding-left: 78px;
    }
    .slope-mode-link {
      display: inline-block;
      font-size: 11px;
      color: #8B7355;
      cursor: pointer;
      text-decoration: none;
      font-weight: 600;
      margin-top: 4px;
    }
    .slope-mode-link:hover {
      color: #6B5335;
      text-decoration: underline;
    }

    .slope-pt-label {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #8B7355;
      color: #fff;
      font-size: 11px;
      font-weight: 700;
      flex-shrink: 0;
    }

    .slope-point-start .slope-pt-label {
      background: #aaa;
    }

    .slope-dist-input,
    .slope-fall-input {
      width: 65px;
      padding: 3px 6px;
      border: 1px solid #8B7355;
      border-radius: 3px;
      font-size: 12px;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      text-align: center;
    }

    .slope-dist-input:focus,
    .slope-fall-input:focus {
      outline: none;
      border-color: #6B5335;
      box-shadow: 0 0 0 2px rgba(139,115,85,0.2);
    }

    .slope-section .slope-actions {
      display: flex;
      gap: 8px;
      margin-top: 8px;
    }

    .slope-section .btn-slope {
      padding: 5px 12px;
      background: #8B7355;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 700;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    }

    .slope-section .btn-slope:hover {
      background: #6B5335;
    }

    .slope-point-delete {
      background: none;
      border: none;
      color: #dc2626;
      cursor: pointer;
      font-size: 14px;
      font-weight: 700;
      padding: 2px 4px;
    }

    .slope-point-delete:hover {
      background: #fee2e2;
      border-radius: 3px;
    }

    /* Quick Retaining Tool */
    .quick-retaining {
      background: #fef3c7;
      border: 1px solid #4C6A70;
      padding: 14px;
      border-radius: 4px;
      margin-bottom: 16px;
    }

    .quick-retaining h3 {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 700;
      font-size: 13px;
      margin-bottom: 10px;
      color: #293C46;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .quick-retaining-row {
      display: flex;
      gap: 10px;
      align-items: end;
    }

    /* Panel Table */
    .panel-table-section {
      margin-bottom: 16px;
    }

    .panel-table-section h3 {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 700;
      font-size: 13px;
      margin-bottom: 8px;
      color: #293C46;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .panel-table-wrap {
      max-height: 400px;
      overflow-y: auto;
      border: 1px solid #4C6A70;
      border-radius: 4px;
    }

    .panel-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }

    .panel-table thead {
      position: sticky;
      top: 0;
      z-index: 1;
    }

    .panel-table th {
      background: #F5F5F5;
      padding: 6px 6px;
      text-align: center;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 700;
      font-size: 11px;
      color: #293C46;
      border-bottom: 2px solid #4C6A70;
      text-transform: uppercase;
      letter-spacing: 0.3px;
      white-space: nowrap;
    }

    .panel-table td {
      padding: 4px 4px;
      border-bottom: 1px solid #e5e7eb;
      text-align: center;
      font-size: 12px;
    }

    .panel-table tbody tr:nth-child(even) {
      background: #F5F5F5;
    }

    .panel-table tbody tr:hover {
      background: #e0f2fe;
    }

    .panel-table select {
      padding: 2px 4px;
      border: 1px solid #4C6A70;
      border-radius: 3px;
      font-size: 12px;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      text-align: center;
    }

    .panel-table .col-pnum {
      width: 30px;
      font-weight: 700;
      color: #293C46;
    }

    .panel-table .col-ht {
      width: 55px;
    }

    .panel-table .col-slope {
      width: 40px;
      color: #8B7355;
      text-align: center;
    }

    .panel-table .col-ret {
      width: 65px;
    }

    .panel-table .col-pl {
      width: 45px;
      font-weight: 700;
      color: #4C6A70;
    }

    .panel-table .col-step {
      width: 48px;
      color: #4C6A70;
    }

    .panel-table .col-total {
      width: 50px;
      font-weight: 700;
    }

    .panel-table .col-post {
      width: 55px;
      font-weight: 700;
    }

    .panel-table .col-del {
      width: 20px;
    }

    .total-standard {
      color: #16a34a;
    }

    .total-elevated {
      color: #F15A29;
    }

    .post-patio {
      color: #F15A29;
    }

    .delete-panel-btn {
      background: none;
      border: none;
      color: #dc2626;
      cursor: pointer;
      font-size: 14px;
      font-weight: 700;
      padding: 2px 4px;
    }

    .delete-panel-btn:hover {
      background: #fee2e2;
      border-radius: 3px;
    }

    /* Gates */
    .gates-section {
      margin-bottom: 16px;
    }

    .gates-section h3 {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 700;
      font-size: 13px;
      margin-bottom: 8px;
      color: #293C46;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .gate-row {
      display: flex;
      gap: 8px;
      align-items: center;
      padding: 6px 0;
      border-bottom: 1px solid #e5e7eb;
    }

    .gate-row select,
    .gate-row input {
      padding: 4px 6px;
      border: 1px solid #4C6A70;
      border-radius: 3px;
      font-size: 12px;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    }

    /* Right Panel */
    .view-tabs {
      display: flex;
      background: #F5F5F5;
      border-bottom: 1px solid #4C6A70;
      padding: 0 16px;
    }

    .view-tab {
      padding: 10px 20px;
      background: transparent;
      border: none;
      cursor: pointer;
      font-size: 13px;
      font-weight: 700;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      color: #4C6A70;
      border-bottom: 3px solid transparent;
    }

    .view-tab.active {
      color: #F15A29;
      border-bottom-color: #F15A29;
    }

    .visualiser-placeholder {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      color: #4C6A70;
      font-weight: 400;
    }

    .profile-view-container {
      flex: 1;
      position: relative;
      overflow: hidden;
      cursor: grab;
      background: #f0f4f8;
    }

    .profile-view-container:active {
      cursor: grabbing;
    }

    .profile-view-container canvas {
      display: block;
    }

    .pv-tooltip {
      position: absolute;
      pointer-events: none;
      background: rgba(41,60,70,0.92);
      color: #fff;
      font-size: 11px;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 600;
      padding: 4px 8px;
      border-radius: 4px;
      white-space: nowrap;
      z-index: 10;
      transition: opacity 0.1s;
    }

    .soil-handle-tooltip {
      position: absolute;
      pointer-events: none;
      background: rgba(139,115,85,0.95);
      color: #fff;
      font-size: 11px;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 600;
      padding: 4px 10px;
      border-radius: 4px;
      white-space: nowrap;
      z-index: 12;
      display: none;
    }

    .pv-reset-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      z-index: 10;
      background: rgba(255,255,255,0.92);
      border: 1px solid #c0c8cc;
      border-radius: 4px;
      padding: 4px 10px;
      font-size: 11px;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 600;
      color: #293C46;
      cursor: pointer;
      transition: background 0.15s;
    }
    .pv-reset-btn:hover {
      background: rgba(255,255,255,1);
      border-color: #8899a4;
    }

    .panel-table tbody tr.panel-row-highlight {
      background: rgba(241,90,41,0.12) !important;
      outline: 2px solid #F15A29;
      outline-offset: -2px;
    }

    .stats-bar {
      background: #FFFFFF;
      border-top: 1px solid #4C6A70;
      padding: 14px 20px;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 12px;
      margin-bottom: 14px;
    }

    .stat-item {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .stat-item label {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 700;
      font-size: 10px;
      color: #4C6A70;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .stat-item .value {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-size: 16px;
      font-weight: 700;
      color: #293C46;
    }

    .stat-item .value.price-badge {
      color: #16a34a;
    }

    .generate-btn {
      width: 100%;
      padding: 12px;
      background: #F15A29;
      color: #FFFFFF;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 15px;
      font-weight: 700;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    }

    .generate-btn:hover {
      background: #d94e22;
    }

    /* Compliance Warnings */
    .compliance-warning {
      border: 1px solid #dc2626;
      border-left: 4px solid #dc2626;
      padding: 10px 14px;
      margin-bottom: 12px;
      border-radius: 4px;
      background: #fef2f2;
    }

    .compliance-warning.warn {
      border-color: #f59e0b;
      background: #fffbeb;
    }

    .compliance-warning h4 {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 700;
      font-size: 13px;
      margin-bottom: 4px;
    }

    .compliance-warning p {
      font-size: 12px;
    }

    /* Colour swatch in dropdown */
    .colour-option-swatch {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 2px;
      border: 1px solid #ccc;
      vertical-align: middle;
      margin-right: 6px;
    }

    /* No shadows heavier than spec */
    * {
      box-shadow: none;
    }

    /* Job Settings Section */
    .job-settings-section {
      background: #F5F5F5;
      border: 1px solid #4C6A70;
      border-radius: 4px;
      margin-bottom: 16px;
    }

    .job-settings-toggle {
      width: 100%;
      padding: 10px 14px;
      background: #F5F5F5;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 700;
      font-size: 13px;
      color: #293C46;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .job-settings-toggle:hover {
      background: #eef0f2;
    }

    .job-settings-toggle .toggle-arrow {
      font-size: 12px;
      transition: transform 0.2s;
    }

    .job-settings-toggle .toggle-arrow.open {
      transform: rotate(90deg);
    }

    .job-settings-body {
      padding: 0 14px 14px 14px;
    }

    .job-settings-body.collapsed {
      display: none;
    }

    .js-row {
      display: flex;
      gap: 10px;
      align-items: end;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }

    .js-row .form-group {
      flex: 1;
      min-width: 100px;
    }

    .js-opt-row {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 0;
      font-size: 12px;
    }

    .js-opt-row input[type="checkbox"] {
      margin: 0;
    }

    .js-opt-row input[type="number"],
    .js-opt-row input[type="text"],
    .js-opt-row select {
      padding: 3px 6px;
      border: 1px solid #4C6A70;
      border-radius: 3px;
      font-size: 12px;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      width: 65px;
    }

    .js-opt-row .js-desc-input {
      width: 120px;
    }

    .js-opt-row .js-price-input {
      width: 70px;
    }

    .js-opt-row .js-unit-input {
      width: 50px;
    }

    .js-label {
      font-size: 11px;
      font-weight: 700;
      color: #4C6A70;
      text-transform: uppercase;
      letter-spacing: 0.3px;
      margin-top: 8px;
      margin-bottom: 4px;
    }

    .js-notes {
      width: 100%;
      min-height: 50px;
      padding: 6px 8px;
      border: 1px solid #4C6A70;
      border-radius: 4px;
      font-size: 12px;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      resize: vertical;
    }

    .js-notes:focus {
      outline: none;
      border-color: #F15A29;
      box-shadow: 0 0 0 2px rgba(241, 90, 41, 0.15);
    }
  </style>
</head>
<body>
  <!-- Header Bar -->
  <div class="header">
    <div class="header-brand">SW</div>
    <div class="header-group">
      <label>Job Ref</label>
      <input type="text" id="jobRef" placeholder="SW9248">
    </div>
    <div class="header-group">
      <label>Client</label>
      <input type="text" id="client" placeholder="Client name">
    </div>
    <div class="header-group">
      <label>Address</label>
      <input type="text" id="address" placeholder="Site address" style="min-width:160px;">
    </div>
    <div class="header-group">
      <label>Supplier</label>
      <select id="supplier">
        <option value="RNR">RNR</option>
        <option value="Metroll">Metroll</option>
        <option value="Lysaght">Lysaght</option>
        <option value="Stratco">Stratco</option>
      </select>
    </div>
    <div class="header-group">
      <label>Profile</label>
      <select id="profile"></select>
    </div>
    <div class="header-group">
      <label>Colour</label>
      <select id="colour"></select>
    </div>
    <div class="header-group">
      <label>$/Metre</label>
      <input type="number" id="pricePerMetre" value="115" step="0.01" min="0" style="min-width:70px;">
    </div>
    <div class="header-actions">
      <span class="saved-indicator" id="savedIndicator">Saved</span>
      <button class="btn-header" onclick="app.newJob()">New</button>
    </div>
  </div>

  <!-- Main Layout -->
  <div class="main">
    <!-- Left Panel -->
    <div class="left-panel">
      <div class="run-tabs" id="runTabs"></div>
      <div class="run-content" id="runContent"></div>
    </div>

    <!-- Right Panel -->
    <div class="right-panel">
      <div class="view-tabs">
        <button class="view-tab active" onclick="app.switchView('profile')">Profile View</button>
        <button class="view-tab" onclick="app.switchView('3d')">3D View</button>
      </div>
      <div class="profile-view-container" id="profileViewContainer">
        <canvas id="profileCanvas"></canvas>
        <div class="pv-tooltip" id="pvTooltip" style="display:none;"></div>
        <div class="soil-handle-tooltip" id="soilHandleTooltip"></div>
        <button class="pv-reset-btn" onclick="app.resetProfileView()">Reset View</button>
      </div>
      <div class="visualiser-placeholder" id="threeDPlaceholder" style="display:none;">
        3D View — coming soon
      </div>

      <!-- Stats Bar -->
      <div class="stats-bar">
        <div class="stats-grid">
          <div class="stat-item">
            <label>Metres</label>
            <div class="value" id="statMetres">0.0m</div>
          </div>
          <div class="stat-item">
            <label>Panels</label>
            <div class="value" id="statPanels">0</div>
          </div>
          <div class="stat-item">
            <label>Posts</label>
            <div class="value" id="statPosts">0</div>
          </div>
          <div class="stat-item">
            <label>Plinths</label>
            <div class="value" id="statPlinths">0</div>
          </div>
          <div class="stat-item">
            <label>Est. Total</label>
            <div class="value price-badge" id="statCost">$0</div>
          </div>
        </div>
        <button class="generate-btn" onclick="app.generateOutputs()">Generate Outputs</button>
      </div>
    </div>
  </div>

  <script>
    // ── Section 4B: Supplier profiles ──
    const SUPPLIER_PROFILES = {
      RNR:    { profiles: ['Ridgeside', 'Sameside'], panelWidth: 2380 },
      Metroll:{ profiles: ['Trimclad', 'Harmony'],   panelWidth: 2365 },
      Lysaght:{ profiles: ['Neetascreen', 'Smartascreen'], panelWidth: 2360 },
      Stratco:{ profiles: ['Superdek', 'Good Neighbour'],  panelWidth: 2350 }
    };

    // ── Section 9: Colorbond fencing colour palette ──
    const COLOURS_STOCK = [
      { name: 'Surfmist',       hex: '#E4E2D5' },
      { name: 'Domain',         hex: '#E8DBAE' },
      { name: 'Evening Haze',   hex: '#C5C2AA' },
      { name: 'Paperbark',      hex: '#CABFA4' },
      { name: 'Dune',           hex: '#B1ADA3' },
      { name: 'Shale Grey',     hex: '#BDBFBA' },
      { name: 'Riversand',      hex: '#9D8D76' },
      { name: 'Bluegum',        hex: '#969799' },
      { name: 'Pale Eucalypt',  hex: '#7C846A' },
      { name: 'Wilderness',     hex: '#64715E' },
      { name: 'Basalt',         hex: '#6D6C6E' },
      { name: 'Woodland Grey',  hex: '#4B4C46' },
      { name: 'Ironstone',      hex: '#3E434C' },
      { name: 'Monument',       hex: '#323233' },
      { name: 'Wollemi',        hex: '#0A1C0D' }
    ];

    const COLOURS_SPECIAL = [
      { name: 'Deep Ocean',   hex: '#364152' },
      { name: 'Cottage Green',hex: '#304C3C' },
      { name: 'Night Sky',    hex: '#2E2E2F' },
      { name: 'Manor Red',    hex: '#5E1D0E' },
      { name: 'Jasper',       hex: '#6C6153' },
      { name: 'Windspray',    hex: '#888B8A' }
    ];

    // ── Section 6.3: Post height lookup tables ──
    // Key: sheetHeight, Value: array of { maxRetaining, postSize, patioTube }
    const POST_LOOKUP = {
      1200: [
        { ret: 0,   post: 2400, patio: false },
        { ret: 150, post: 2400, patio: false },
        { ret: 300, post: 2400, patio: false },
        { ret: 450, post: 2400, patio: true },
        { ret: 600, post: 2400, patio: true }
      ],
      1500: [
        { ret: 0,   post: 2400, patio: false },
        { ret: 150, post: 2400, patio: false },
        { ret: 300, post: 2400, patio: false },
        { ret: 450, post: 2700, patio: true },
        { ret: 600, post: 2700, patio: true }
      ],
      1800: [
        { ret: 0,   post: 2400, patio: false },
        { ret: 150, post: 2700, patio: false },
        { ret: 300, post: 2700, patio: false },
        { ret: 450, post: 3000, patio: true },
        { ret: 600, post: 3000, patio: true }
      ],
      2100: [
        { ret: 0,   post: 2700, patio: false },
        { ret: 150, post: 3000, patio: false },
        { ret: 300, post: 3000, patio: false },
        { ret: 450, post: 3000, patio: true },
        { ret: 600, post: 3000, patio: true }
      ]
    };

    const RETAINING_OPTIONS = [0, 150, 300, 450, 600];
    const SHEET_HEIGHTS = [1200, 1500, 1800, 2100];
    const RUN_NAME_CYCLE = ['Rear', 'LHS', 'RHS', 'Front'];

    // ── Business rules: cost prices (internal) ──
    const COST_PRICES = {
      panelKit1800_2400: 185,  // 1800H panel kit with 2400 posts, per panel
      panelKit1800_2700: 210,  // 1800H panel kit with 2700 posts
      panelKit1800_3000: 235,  // 1800H panel kit with 3000 posts
      panelKit1500_2400: 165,
      panelKit1200_2400: 145,
      panelKit2100_2700: 230,
      panelKit2100_3000: 255,
      plinth: 28,              // per plinth (150mm)
      patioTube: 45,           // 76x38 RHS 3000mm
      gateKitPedestrian: 320,  // pedestrian gate kit
      gateKitDouble: 580,      // double swing gate kit
      gatePost90x90: 85,       // 90x90mm SHS gate post
      concrete: 9.50,          // per bag
      tekScrewBox: 18,         // per box
      removeHardieSheet: 25,   // per sheet
      removeTimberLap: 15,     // per metre
      removeAsbestosSheet: 85, // per sheet (licenced disposal)
      vegClear: 150,           // flat fee
      groundMulch: 12,         // per lineal metre
      groundStones: 18,        // per lineal metre
      groundTurf: 22,          // per lineal metre
      labourPerMetre: 35,      // base labour rate per metre
      delivery: 250            // default delivery
    };

    const MARGIN = 0.30; // 30% margin: sell = cost / (1 - 0.30)

    const ACCESS_SURCHARGE = { easy: 0, moderate: 0.10, difficult: 0.20 }; // % of labour
    const URGENCY_SURCHARGE = { standard: 0, urgent: 0.10, rush: 0.20, emergency: 0.35 }; // % of subtotal

    const DISCLAIMERS = [
      'This quote is based on information provided and a standard site assessment. Actual costs may vary if unforeseen conditions are encountered (e.g., rock, tree roots, underground services).',
      'Customer is responsible for confirming property boundaries before installation. SecureWorks WA accepts no liability for fencing installed on incorrect boundaries.',
      'Retaining walls over 500mm in height may require a Building Permit and engineer certification under WA Building Regulations. Customer is responsible for obtaining all required approvals.',
      'This quote does not include any electrical or plumbing relocation, tree removal requiring council approval, or asbestos removal unless specifically listed.',
      'Payment terms: 50% deposit required to confirm booking. Balance due on completion. Overdue accounts incur 2% monthly interest.',
      'All materials carry the manufacturer\'s standard warranty (BlueScope 10-year fencing warranty on COLORBOND steel). Workmanship warranty: 12 months from completion.'
    ];

    // ── Lookup helper ──
    function lookupPost(sheetHeight, retaining) {
      const table = POST_LOOKUP[sheetHeight] || POST_LOOKUP[1800];
      const entry = table.find(e => e.ret === retaining);
      if (entry) return entry;
      // Fallback: use the formula from Section 6.3
      const totalFence = sheetHeight + retaining;
      const required = totalFence + 600;
      let postSize;
      if (required <= 2400) postSize = 2400;
      else if (required <= 2700) postSize = 2700;
      else if (required <= 3000) postSize = 3000;
      else postSize = 3000;
      const plinths = retaining / 150;
      return { ret: retaining, post: postSize, patio: plinths >= 3 && plinths <= 4 };
    }

    // ── Application ──
    const app = {
      job: null,
      currentRunId: null,

      init() {
        this.loadFromStorage();
        this.populateColourDropdown();
        this.bindHeaderInputs();

        if (!this.job) {
          this.job = {
            ref: '',
            client: '',
            address: '',
            supplier: 'RNR',
            profile: 'Ridgeside',
            colour: 'Shale Grey',
            pricePerMetre: 115,
            runs: [],
            gates: [],
            date: new Date().toISOString().slice(0, 10)
          };
          this.addRun();
        } else {
          this.syncHeaderFromJob();
          if (this.job.runs.length > 0 && !this.currentRunId) {
            this.currentRunId = this.job.runs[0].id;
          }
        }

        this.updateProfileDropdown();
        this._loadPanelTexture();
        this.render();

        // Resize handler for profile view canvas
        window.addEventListener('resize', () => this.renderProfileView());
      },

      // ── Colour dropdown (Section 9.3) ──
      populateColourDropdown() {
        const select = document.getElementById('colour');
        let html = '<optgroup label="── Stock ──">';
        COLOURS_STOCK.forEach(c => {
          html += `<option value="${c.name}" data-hex="${c.hex}">${c.name}</option>`;
        });
        html += '</optgroup><optgroup label="── Special Order ──">';
        COLOURS_SPECIAL.forEach(c => {
          html += `<option value="${c.name}" data-hex="${c.hex}">${c.name} (SO)</option>`;
        });
        html += '</optgroup>';
        select.innerHTML = html;
      },

      // ── Profile dropdown (Section 4B) ──
      updateProfileDropdown() {
        const select = document.getElementById('profile');
        const supplierData = SUPPLIER_PROFILES[this.job.supplier];
        select.innerHTML = supplierData.profiles.map(p =>
          `<option value="${p}" ${p === this.job.profile ? 'selected' : ''}>${p}</option>`
        ).join('');
        // If current profile is not valid for new supplier, reset to default
        if (!supplierData.profiles.includes(this.job.profile)) {
          this.job.profile = supplierData.profiles[0];
          select.value = this.job.profile;
        }
      },

      bindHeaderInputs() {
        document.getElementById('jobRef').addEventListener('input', (e) => {
          this.job.ref = e.target.value;
          this.save();
        });
        document.getElementById('client').addEventListener('input', (e) => {
          this.job.client = e.target.value;
          this.save();
        });
        document.getElementById('address').addEventListener('input', (e) => {
          this.job.address = e.target.value;
          this.save();
        });
        document.getElementById('supplier').addEventListener('change', (e) => {
          this.job.supplier = e.target.value;
          this.updateProfileDropdown();
          this.recalculateAll();
          this.save();
        });
        document.getElementById('profile').addEventListener('change', (e) => {
          this.job.profile = e.target.value;
          this.save();
        });
        document.getElementById('colour').addEventListener('change', (e) => {
          this.job.colour = e.target.value;
          this.renderProfileView();
          this.save();
        });
        document.getElementById('pricePerMetre').addEventListener('input', (e) => {
          this.job.pricePerMetre = parseFloat(e.target.value) || 0;
          this.updateStats();
          this.save();
        });
      },

      syncHeaderFromJob() {
        document.getElementById('jobRef').value = this.job.ref || '';
        document.getElementById('client').value = this.job.client || '';
        document.getElementById('address').value = this.job.address || '';
        document.getElementById('supplier').value = this.job.supplier || 'RNR';
        document.getElementById('colour').value = this.job.colour || 'Shale Grey';
        document.getElementById('pricePerMetre').value = this.job.pricePerMetre || 115;
      },

      // ── Section 3.5: Panel width by supplier ──
      getPanelWidthMm() {
        return SUPPLIER_PROFILES[this.job.supplier].panelWidth;
      },

      getPanelWidthM() {
        return this.getPanelWidthMm() / 1000;
      },

      // ── Section 6.1: Auto-calculate panel count from run length ──
      calcPanelCount(lengthM) {
        if (!lengthM || lengthM <= 0) return 0;
        const lengthMm = lengthM * 1000;
        return Math.ceil(lengthMm / this.getPanelWidthMm());
      },

      // ── Section 6.3: Post height per-post (between two panels) ──
      getPostHeight(leftPanel, rightPanel) {
        let leftTotal = 0, rightTotal = 0;
        let leftLookup = null, rightLookup = null;

        if (leftPanel) {
          leftTotal = leftPanel.height + leftPanel.retaining;
          leftLookup = lookupPost(leftPanel.height, leftPanel.retaining);
        }
        if (rightPanel) {
          rightTotal = rightPanel.height + rightPanel.retaining;
          rightLookup = lookupPost(rightPanel.height, rightPanel.retaining);
        }

        // Use whichever side demands the taller post
        let postSize = 2400;
        let patio = false;

        if (leftLookup && rightLookup) {
          postSize = Math.max(leftLookup.post, rightLookup.post);
          patio = leftLookup.patio || rightLookup.patio;
        } else if (leftLookup) {
          postSize = leftLookup.post;
          patio = leftLookup.patio;
        } else if (rightLookup) {
          postSize = rightLookup.post;
          patio = rightLookup.patio;
        }

        return { postSize, patio };
      },

      // ── Sync panels to match calculated panel count ──
      syncPanels(run) {
        const targetCount = this.calcPanelCount(run.length);
        if (targetCount === 0) {
          run.panels = [];
          return;
        }

        while (run.panels.length < targetCount) {
          run.panels.push({
            id: 'panel-' + Date.now() + '-' + Math.random().toString(36).slice(2, 6),
            height: run.sheetHeight,
            retaining: 0,
            step: 'level',
            stepMm: 0,
            slopePlinths: 0
          });
        }

        // If decreased, remove from end (but only excess)
        if (run.panels.length > targetCount) {
          run.panels = run.panels.slice(0, targetCount);
        }

        // Sync slope points to match current run length
        this.syncSlopePoints(run);
      },

      // ── Compute derived values per panel (not stored, used for display) ──
      getPanelDerived(panel) {
        const slopePlinths = panel.slopePlinths || 0;
        const manualPlinths = panel.retaining / 150;
        const rawPlinths = slopePlinths + manualPlinths;
        const plinths = Math.min(4, rawPlinths); // Total capped at 4
        const plinthsCapped = rawPlinths > 4;
        const totalRetaining = plinths * 150;
        const totalHeight = panel.height + totalRetaining;
        const lookup = lookupPost(panel.height, Math.min(600, totalRetaining));
        return {
          plinths,
          rawPlinths,
          plinthsCapped,
          slopePlinths,
          manualPlinths,
          totalRetaining,
          totalHeight,
          postSize: lookup.post,
          patio: lookup.patio,
          needsPatioTube: plinths >= 3 && plinths <= 4
        };
      },

      // ── Compute post array for a run (posts = panels + 1) ──
      getRunPosts(run) {
        const posts = [];
        for (let i = 0; i <= run.panels.length; i++) {
          const leftPanel = i > 0 ? run.panels[i - 1] : null;
          const rightPanel = i < run.panels.length ? run.panels[i] : null;
          posts.push(this.getPostHeight(leftPanel, rightPanel));
        }
        return posts;
      },

      // ── Ground height interpolation: get heightMm at a distance along the run ──
      // slopePoints is [{distanceM, heightMm}, ...] sorted by distanceM
      computeGroundHeight(slopePoints, distanceM) {
        if (!slopePoints || slopePoints.length === 0) return 0;
        if (slopePoints.length === 1) return slopePoints[0].heightMm;
        if (distanceM <= slopePoints[0].distanceM) return slopePoints[0].heightMm;
        if (distanceM >= slopePoints[slopePoints.length - 1].distanceM) return slopePoints[slopePoints.length - 1].heightMm;
        for (let j = 0; j < slopePoints.length - 1; j++) {
          if (distanceM >= slopePoints[j].distanceM && distanceM <= slopePoints[j + 1].distanceM) {
            const span = slopePoints[j + 1].distanceM - slopePoints[j].distanceM;
            if (span === 0) return slopePoints[j].heightMm;
            const t = (distanceM - slopePoints[j].distanceM) / span;
            return slopePoints[j].heightMm + t * (slopePoints[j + 1].heightMm - slopePoints[j].heightMm);
          }
        }
        return 0;
      },

      // ── Calculate slope-derived steps and plinths for all panels in a run ──
      // This sets panel.slopePlinths and panel.step based on the slope line.
      // Called whenever slope points change or panels are synced.
      calcSlopeForRun(run) {
        if (!run || !run.panels.length) return;
        const panelCount = run.panels.length;
        const runLengthM = run.length || 0;
        const slopePoints = (run.slope && run.slope.points) || [];
        const plinthH = 150;
        const maxStepsPerPanel = 4; // 600mm max step between adjacent panels

        // Get the interpolated ground height at each post position (panelCount + 1 posts)
        const groundHeights = [];
        for (let i = 0; i <= panelCount; i++) {
          const distM = runLengthM > 0 ? (i / panelCount) * runLengthM : 0;
          groundHeights.push(this.computeGroundHeight(slopePoints, distM));
        }

        // Each panel spans from post i to post i+1.
        // The panel's "base level" snaps to the nearest plinthH step below the ground.
        // We work left-to-right. Panel 0's base = 0 (reference).
        // For each subsequent panel, the base steps down/up when ground changes enough.

        // Panel base levels (in mm, relative to start — negative = lower, positive = higher)
        const baseLevels = new Array(panelCount).fill(0);
        baseLevels[0] = 0; // First panel is the reference

        for (let i = 1; i < panelCount; i++) {
          // Ground height at this panel's left post
          const groundAtPost = groundHeights[i];
          // How far has ground dropped from the previous panel's base?
          const prevBase = baseLevels[i - 1];
          const dropFromPrevBase = prevBase - groundAtPost; // positive = ground is lower
          if (dropFromPrevBase >= plinthH) {
            // Step down by however many full plinths fit, capped at 4 (600mm)
            const steps = Math.min(maxStepsPerPanel, Math.floor(dropFromPrevBase / plinthH));
            baseLevels[i] = prevBase - steps * plinthH;
          } else if (dropFromPrevBase <= -plinthH) {
            // Ground has risen — step up, capped at 4 (600mm)
            const steps = Math.min(maxStepsPerPanel, Math.floor(-dropFromPrevBase / plinthH));
            baseLevels[i] = prevBase + steps * plinthH;
          } else {
            baseLevels[i] = prevBase;
          }
        }

        // Now calculate slopePlinths, step direction, and stepMm for each panel
        for (let i = 0; i < panelCount; i++) {
          const panel = run.panels[i];

          // Slope plinths = how far this panel's base is above the lowest ground
          // at either end of the panel, measured in plinth units
          const groundLeft = groundHeights[i];
          const groundRight = groundHeights[i + 1];
          const lowestGround = Math.min(groundLeft, groundRight);
          const gapMm = baseLevels[i] - lowestGround; // how far base is above ground
          const slopePlinths = Math.max(0, Math.min(4, Math.round(gapMm / plinthH)));
          panel.slopePlinths = slopePlinths;

          // Step direction and magnitude: compare this panel's base to previous
          if (i === 0) {
            panel.step = 'level';
            panel.stepMm = 0;
          } else {
            const diff = baseLevels[i] - baseLevels[i - 1];
            if (diff < 0) panel.step = 'down';
            else if (diff > 0) panel.step = 'up';
            else panel.step = 'level';
            panel.stepMm = diff; // negative = down, positive = up, 0 = level
          }
        }
      },

      recalculateAll() {
        this.job.runs.forEach(run => this.syncPanels(run));
        this.render();
      },

      // ── Runs ──
      addRun() {
        const idx = this.job.runs.length;
        const name = idx < RUN_NAME_CYCLE.length ? RUN_NAME_CYCLE[idx] : 'Custom';
        const run = {
          id: 'run-' + Date.now(),
          name: name,
          length: 0,
          sheetHeight: 1800,
          extension: 'none',
          panels: [],
          slope: { mode: 'simple', points: [], simple: { direction: 'left-to-right', totalFallMm: 0, startsFrom: 'start' }, monotonic: null }
        };
        this.job.runs.push(run);
        this.currentRunId = run.id;
        this.save();
        this.render();
      },

      deleteRun(runId) {
        if (this.job.runs.length <= 1) {
          alert('Must have at least one run.');
          return;
        }
        if (!confirm('Delete this run?')) return;
        this.job.runs = this.job.runs.filter(r => r.id !== runId);
        if (this.currentRunId === runId) {
          this.currentRunId = this.job.runs[0].id;
        }
        this.save();
        this.render();
      },

      switchRun(runId) {
        this.currentRunId = runId;
        this.render();
      },

      // ── Slope point management ──

      syncSlopePoints(run) {
        if (!run.slope) run.slope = { mode: 'simple', points: [], simple: { direction: 'left-to-right', totalFallMm: 0, startsFrom: 'start' }, monotonic: null };
        if (!run.slope.simple) run.slope.simple = { direction: 'left-to-right', totalFallMm: 0, startsFrom: 'start' };
        if (run.slope.mode === undefined) run.slope.mode = 'simple';
        const pts = run.slope.points;
        const runLen = run.length || 0;
        const isAdvanced = run.slope.mode === 'advanced';

        // In simple mode, regenerate points from simple inputs
        if (!isAdvanced) {
          this._generateSimpleSlopePoints(run);
          return;
        }

        // Advanced mode: ensure start and end points exist
        const startIdx = pts.findIndex(p => p.distanceM === 0);
        if (startIdx < 0) {
          pts.unshift({ distanceM: 0, heightMm: 0 });
        }
        // In advanced mode, do NOT force start point to 0 — Point A is unlocked

        if (runLen > 0) {
          // Remove intermediate points beyond run length (keep first/start)
          for (let i = pts.length - 1; i >= 1; i--) {
            if (pts[i].distanceM > runLen) pts.splice(i, 1);
          }

          // Ensure end point exists at runLen
          const endIdx = pts.findIndex(p => p.distanceM === runLen);
          if (endIdx < 0) {
            const lastPt = pts[pts.length - 1];
            pts.push({ distanceM: runLen, heightMm: lastPt ? lastPt.heightMm : 0 });
          }
        } else {
          pts.length = 1;
        }

        pts.sort((a, b) => a.distanceM - b.distanceM);
      },

      // Generate slope points from simple mode inputs
      _generateSimpleSlopePoints(run) {
        const slope = run.slope;
        if (!slope.simple) slope.simple = { direction: 'left-to-right', totalFallMm: 0, startsFrom: 'start' };
        const simple = slope.simple;
        const runLen = run.length || 0;
        if (runLen <= 0) {
          slope.points = [{ distanceM: 0, heightMm: 0 }];
          return;
        }
        const totalFall = simple.totalFallMm || 0;
        const startPctMap = { 'start': 0, '25': 0.25, '50': 0.50, '75': 0.75 };
        const startPct = startPctMap[simple.startsFrom] || 0;

        // Build points for left-to-right direction first
        let points;
        if (totalFall === 0) {
          points = [
            { distanceM: 0, heightMm: 0 },
            { distanceM: runLen, heightMm: 0 }
          ];
        } else if (startPct === 0) {
          // Gradual slope across entire run
          points = [
            { distanceM: 0, heightMm: 0 },
            { distanceM: runLen, heightMm: -totalFall }
          ];
        } else {
          // Flat portion then slope
          const flatEndM = Math.round(startPct * runLen * 2) / 2;
          points = [
            { distanceM: 0, heightMm: 0 },
            { distanceM: Math.min(flatEndM, runLen - 0.5), heightMm: 0 },
            { distanceM: runLen, heightMm: -totalFall }
          ];
        }

        // If right-to-left, mirror the profile horizontally
        if (simple.direction === 'right-to-left') {
          points = points.map(p => ({
            distanceM: Math.round((runLen - p.distanceM) * 2) / 2,
            heightMm: p.heightMm
          }));
          points.sort((a, b) => a.distanceM - b.distanceM);
        }

        slope.points = points;
      },

      // Toggle between simple and advanced slope modes
      toggleSlopeMode(runId) {
        const run = this.job.runs.find(r => r.id === runId);
        if (!run || !run.slope) return;

        if (run.slope.mode === 'simple') {
          // Switch to advanced: keep current points, add userSet flags
          run.slope.mode = 'advanced';
          run.slope.monotonic = null;
          run.slope.points.forEach(p => { p.userSet = false; });
        } else {
          // Switch back to simple: calculate closest simple values
          this._slopeAdvancedToSimple(run);
          this._generateSimpleSlopePoints(run);
        }

        this.calcSlopeForRun(run);
        this.save();
        this.render();
      },

      // Calculate closest simple mode values from advanced profile
      _slopeAdvancedToSimple(run) {
        const pts = run.slope.points;
        if (!pts || pts.length < 2) {
          run.slope.simple = { direction: 'left-to-right', totalFallMm: 0, startsFrom: 'start' };
          run.slope.mode = 'simple';
          run.slope.monotonic = null;
          return;
        }

        const firstH = pts[0].heightMm || 0;
        const lastH = pts[pts.length - 1].heightMm || 0;
        const diff = lastH - firstH; // negative = falls L→R, positive = rises L→R

        let direction, totalFall;
        if (diff <= 0) {
          direction = 'left-to-right';
          totalFall = Math.abs(diff);
        } else {
          direction = 'right-to-left';
          totalFall = diff;
        }

        // Snap totalFall to nearest 150mm
        totalFall = Math.round(totalFall / 150) * 150;
        totalFall = Math.min(1800, Math.max(0, totalFall));

        // Detect startsFrom by checking for flat initial portion
        let startsFrom = 'start';
        const runLen = run.length || pts[pts.length - 1].distanceM;
        if (pts.length >= 3 && runLen > 0) {
          const highEndH = direction === 'left-to-right' ? firstH : lastH;
          // Check intermediate points near the high-end level
          for (let i = 1; i < pts.length - 1; i++) {
            if (Math.abs(pts[i].heightMm - highEndH) < 30) {
              const pct = direction === 'left-to-right'
                ? pts[i].distanceM / runLen
                : (runLen - pts[i].distanceM) / runLen;
              if (pct >= 0.65) startsFrom = '75';
              else if (pct >= 0.40) startsFrom = '50';
              else if (pct >= 0.18) startsFrom = '25';
            }
          }
        }

        run.slope.simple = { direction, totalFallMm: totalFall, startsFrom };
        run.slope.mode = 'simple';
        run.slope.monotonic = null;
      },

      // Update simple mode slope inputs
      updateSimpleSlope(runId, field, value) {
        const run = this.job.runs.find(r => r.id === runId);
        if (!run || !run.slope || !run.slope.simple) return;

        if (field === 'direction') {
          run.slope.simple.direction = value;
        } else if (field === 'totalFallMm') {
          let numVal = parseInt(value, 10) || 0;
          numVal = Math.round(numVal / 150) * 150;
          numVal = Math.max(0, Math.min(1800, numVal));
          run.slope.simple.totalFallMm = numVal;
        } else if (field === 'startsFrom') {
          run.slope.simple.startsFrom = value;
        }

        this._generateSimpleSlopePoints(run);
        this.calcSlopeForRun(run);
        this.save();
        this.render();
      },

      addSlopePoint(runId) {
        const run = this.job.runs.find(r => r.id === runId);
        if (!run || !run.slope) return;
        const pts = run.slope.points;
        if (pts.length < 2) return;

        // Find longest segment
        let maxSpan = 0, maxIdx = 0;
        for (let i = 0; i < pts.length - 1; i++) {
          const span = pts[i + 1].distanceM - pts[i].distanceM;
          if (span > maxSpan) { maxSpan = span; maxIdx = i; }
        }

        const midDist = (pts[maxIdx].distanceM + pts[maxIdx + 1].distanceM) / 2;
        const rounded = Math.round(midDist * 2) / 2;
        const heightMm = this.computeGroundHeight(pts, rounded);

        pts.push({ distanceM: rounded, heightMm: Math.round(heightMm), userSet: false });
        pts.sort((a, b) => a.distanceM - b.distanceM);
        this.calcSlopeForRun(run);
        this.save();
        this.render();
      },

      removeSlopePoint(runId, pointIdx) {
        const run = this.job.runs.find(r => r.id === runId);
        if (!run || !run.slope) return;
        const pts = run.slope.points;
        if (pointIdx <= 0 || pointIdx >= pts.length - 1) return;
        pts.splice(pointIdx, 1);
        this.calcSlopeForRun(run);
        this.save();
        this.render();
      },

      updateSlopePoint(runId, pointIdx, field, value) {
        const run = this.job.runs.find(r => r.id === runId);
        if (!run || !run.slope) return;
        const pts = run.slope.points;
        if (!pts[pointIdx]) return;

        if (field === 'heightMm') {
          // Direct heightMm input (advanced mode, Point A included)
          const numVal = parseFloat(value) || 0;
          pts[pointIdx].heightMm = Math.max(-2400, Math.min(2400, numVal));
          pts[pointIdx].userSet = true;
        } else if (field === 'fallMm') {
          // User enters positive = ground drops, stored as negative heightMm
          const numVal = parseFloat(value) || 0;
          pts[pointIdx].heightMm = -numVal;
          pts[pointIdx].userSet = true;
        } else if (field === 'distanceM') {
          if (pointIdx === 0 || pointIdx === pts.length - 1) return;
          const numVal = parseFloat(value) || 0;
          pts[pointIdx].distanceM = Math.max(0.5, Math.min((run.length || 0) - 0.5, numVal));
          pts.sort((a, b) => a.distanceM - b.distanceM);
          return; // Don't apply waterfall for distance changes
        }

        // Waterfall: auto-adjust subsequent non-userSet points
        const changedHeight = pts[pointIdx].heightMm;
        for (let i = pointIdx + 1; i < pts.length; i++) {
          if (!pts[i].userSet) {
            pts[i].heightMm = changedHeight;
          } else {
            // Enforce monotonic on userSet points
            if (run.slope.monotonic === 'falling') {
              pts[i].heightMm = Math.min(pts[i].heightMm, pts[i - 1].heightMm);
            } else if (run.slope.monotonic === 'rising') {
              pts[i].heightMm = Math.max(pts[i].heightMm, pts[i - 1].heightMm);
            }
          }
        }

        this.calcSlopeForRun(run);
        this.save();
        this.render();
      },

      resetSlope(runId) {
        const run = this.job.runs.find(r => r.id === runId);
        if (!run || !run.slope) return;

        if (run.slope.mode === 'simple') {
          run.slope.simple = { direction: 'left-to-right', totalFallMm: 0, startsFrom: 'start' };
          this._generateSimpleSlopePoints(run);
        } else {
          // Advanced mode: reset all points to 0, clear userSet and monotonic
          run.slope.points.forEach(p => { p.heightMm = 0; p.userSet = false; });
          run.slope.monotonic = null;
        }

        this.calcSlopeForRun(run);
        this.save();
        this.render();
      },

      updateRunSettings(runId, field, value) {
        const run = this.job.runs.find(r => r.id === runId);
        if (!run) return;

        if (field === 'name') {
          run.name = value;
        } else if (field === 'length') {
          run.length = parseFloat(value) || 0;
          this.syncPanels(run);
        } else if (field === 'sheetHeight') {
          run.sheetHeight = parseInt(value);
        } else if (field === 'extension') {
          run.extension = value;
        }

        this.save();
        this.render();
      },

      applyHeightToAll(runId) {
        const run = this.job.runs.find(r => r.id === runId);
        if (!run) return;
        run.panels.forEach(p => { p.height = run.sheetHeight; });
        this.save();
        this.render();
      },

      updatePanel(runId, panelIdx, field, value) {
        const run = this.job.runs.find(r => r.id === runId);
        if (!run || !run.panels[panelIdx]) return;

        const panel = run.panels[panelIdx];
        if (field === 'height') {
          panel.height = parseInt(value);
        } else if (field === 'retaining') {
          panel.retaining = parseInt(value);
        } else if (field === 'step') {
          panel.step = value;
        }

        this.save();
        this.render();
      },

      deletePanel(runId, panelIdx) {
        const run = this.job.runs.find(r => r.id === runId);
        if (!run || run.panels.length <= 1) return;
        run.panels.splice(panelIdx, 1);
        this.save();
        this.render();
      },

      applyQuickRetaining(runId) {
        const run = this.job.runs.find(r => r.id === runId);
        if (!run) return;

        const startPanel = parseInt(document.getElementById(`qr-start-${runId}`).value);
        const endPanel = parseInt(document.getElementById(`qr-end-${runId}`).value);
        const retaining = parseInt(document.getElementById(`qr-retaining-${runId}`).value);

        if (startPanel < 1 || endPanel > run.panels.length || startPanel > endPanel) {
          alert('Invalid panel range.');
          return;
        }

        for (let i = startPanel - 1; i < endPanel; i++) {
          run.panels[i].retaining = retaining;
        }

        this.save();
        this.render();
      },

      // ── Gates ──
      addGate() {
        if (!this.job.runs.length) return;
        this.job.gates.push({
          id: 'gate-' + Date.now(),
          type: 'pedestrian',
          width: 900,
          runIndex: 0,
          afterPanel: 1
        });
        this.save();
        this.render();
      },

      updateGate(gateId, field, value) {
        const gate = this.job.gates.find(g => g.id === gateId);
        if (!gate) return;
        if (field === 'type') gate.type = value;
        else if (field === 'width') gate.width = parseInt(value) || 900;
        else if (field === 'runIndex') gate.runIndex = parseInt(value);
        else if (field === 'afterPanel') gate.afterPanel = parseInt(value);
        this.save();
        this.render();
      },

      deleteGate(gateId) {
        this.job.gates = this.job.gates.filter(g => g.id !== gateId);
        this.save();
        this.render();
      },

      // ── Section 11: Compliance warnings ──
      getComplianceWarnings() {
        const warnings = [];
        this.job.runs.forEach(run => {
          run.panels.forEach((panel, idx) => {
            const totalRetaining = panel.retaining + (panel.slopePlinths || 0) * 150;
            const totalPlinths = totalRetaining / 150;
            if (totalPlinths >= 4) {
              warnings.push({
                type: 'warn',
                msg: `${run.name} P${idx + 1}: Panel at maximum plinth capacity (${totalRetaining}mm). Additional retaining requires engineered solution.`
              });
            }
            if (totalRetaining > 500) {
              warnings.push({
                type: 'warn',
                msg: `${run.name} P${idx + 1}: Retaining >${500}mm requires Building Permit + Engineer Cert in WA.`
              });
            }
          });
        });
        return warnings;
      },

      // ── Stats ──
      updateStats() {
        let totalPanels = 0;
        let totalPosts = 0;
        let totalMetres = 0;
        let totalPlinths = 0;
        let plinthPanelCount = 0;
        const panelWidthM = this.getPanelWidthM();
        const panelWidthMm = this.getPanelWidthMm();

        this.job.runs.forEach(run => {
          const panelCount = run.panels.length;
          totalPanels += panelCount;
          totalPosts += panelCount + 1;
          totalMetres += run.length || 0;
          run.panels.forEach(p => {
            const pl = Math.min(4, (p.slopePlinths || 0) + p.retaining / 150);
            totalPlinths += pl;
            if (pl > 0) plinthPanelCount++;
          });
        });

        // Corner post sharing: if >1 run, subtract shared corners
        // Simple approximation: subtract (runs - 1) for connected runs
        // TODO: proper corner handling needs run-connection data

        const estimate = totalMetres * this.job.pricePerMetre * 1.1;

        document.getElementById('statMetres').textContent =
          totalMetres > 0 ? `${totalMetres.toFixed(1)}m / ${totalPanels} × ${panelWidthMm}mm` : '0.0m';
        document.getElementById('statPanels').textContent = totalPanels;
        document.getElementById('statPosts').textContent = totalPosts;
        document.getElementById('statPlinths').textContent =
          totalPlinths > 0 ? `${totalPlinths} (across ${plinthPanelCount} panels)` : '0';
        document.getElementById('statCost').textContent =
          estimate > 0 ? `$${Math.round(estimate).toLocaleString()} EST.` : '$0';
      },

      // ── New Job ──
      newJob() {
        if (!confirm('Start a new job? This will clear all current data.')) return;
        localStorage.removeItem('fenceJob');
        this.job = null;
        this.currentRunId = null;
        this.init();
      },

      // ── Render ──
      render() {
        // Recalc slope-derived steps + plinths for all runs before rendering
        this.job.runs.forEach(run => this.calcSlopeForRun(run));
        this.renderRunTabs();
        this.renderRunContent();
        this._restoreJobSettings();
        this.updateStats();
        this.renderProfileView();
      },

      renderRunTabs() {
        const tabsHtml = this.job.runs.map(run => {
          const panelCount = run.panels.length;
          return `<div class="run-tab ${run.id === this.currentRunId ? 'active' : ''}"
                       onclick="app.switchRun('${run.id}')">
                    ${run.name}${panelCount > 0 ? ` (${panelCount})` : ''}
                  </div>`;
        }).join('');

        document.getElementById('runTabs').innerHTML = `
          ${tabsHtml}
          <button class="add-run-btn" onclick="app.addRun()">+ Add Run</button>
        `;
      },

      renderRunContent() {
        const run = this.job.runs.find(r => r.id === this.currentRunId);
        if (!run) {
          document.getElementById('runContent').innerHTML =
            '<p style="padding: 20px; color: #4C6A70;">No run selected. Click "+ Add Run" to begin.</p>';
          return;
        }

        // Warnings
        const warnings = this.getComplianceWarnings();
        let warningsHtml = '';
        warnings.forEach(w => {
          const cls = w.type === 'stop' ? '' : 'warn';
          warningsHtml += `<div class="compliance-warning ${cls}">
            <h4>${w.type === 'stop' ? '🔴 STOP' : '⚠️ Warning'}</h4>
            <p>${w.msg}</p>
          </div>`;
        });

        // Compute posts for this run
        const posts = this.getRunPosts(run);

        // Panel table rows
        const panelRows = run.panels.map((panel, idx) => {
          const derived = this.getPanelDerived(panel);
          // Post for this panel = the post to the RIGHT of the panel (post index idx+1)
          // But per spec, "Post" column shows the calculated post height.
          // Post at position idx sits between panel idx-1 and panel idx.
          // We'll show the max post relevant to this panel (max of left and right post).
          const leftPost = posts[idx];
          const rightPost = posts[idx + 1];
          const maxPost = Math.max(leftPost.postSize, rightPost.postSize);
          const anyPatio = leftPost.patio || rightPost.patio;

          const totalClass = derived.totalHeight > 1800 ? 'total-elevated' : 'total-standard';
          const postDisplay = anyPatio
            ? `<span class="post-patio">${maxPost}†</span>`
            : `${maxPost}`;

          // Plinths display: total plinths (slope + manual), append † when >= 3 (patio tube)
          const plinthsDisplay = derived.plinths >= 3 ? `${derived.plinths}†` : `${derived.plinths}`;

          // Slope plinths display (read-only, greyed out)
          const slopePlinthsDisplay = derived.slopePlinths > 0 ? `${derived.slopePlinths}` : '—';

          // Step auto-calculated from slope — shows direction + mm amount
          const stepMm = panel.stepMm || 0;
          let stepDisplay;
          if (stepMm < 0) stepDisplay = '\u2193' + Math.abs(stepMm);
          else if (stepMm > 0) stepDisplay = '\u2191' + stepMm;
          else stepDisplay = '\u2014';

          // Warning badge for max capacity (capped or at limit)
          const maxWarning = derived.plinthsCapped
            ? ' <span title="Max plinth capacity — slope + retaining exceeds 4" style="color:#e65100;font-weight:700;">\u26A0</span>'
            : (derived.plinths >= 4 ? ' <span title="Max retaining — consider engineered wall" style="color:#e65100;font-weight:700;">\u26A0</span>' : '');

          return `<tr data-panel-idx="${idx}" onclick="app.selectPanel(${idx})" style="cursor:pointer;" class="${this.highlightedPanelIdx === idx ? 'panel-row-highlight' : ''}">
            <td class="col-pnum">P${idx + 1}</td>
            <td class="col-ht">
              <select onchange="app.updatePanel('${run.id}', ${idx}, 'height', this.value)">
                ${SHEET_HEIGHTS.map(h =>
                  `<option value="${h}" ${panel.height === h ? 'selected' : ''}>${h / 100}</option>`
                ).join('')}
              </select>
            </td>
            <td class="col-slope" style="color:#8B7355;text-align:center;">${slopePlinthsDisplay}</td>
            <td class="col-ret">
              <select onchange="app.updatePanel('${run.id}', ${idx}, 'retaining', this.value)">
                ${RETAINING_OPTIONS.map(r =>
                  `<option value="${r}" ${panel.retaining === r ? 'selected' : ''}>${r}</option>`
                ).join('')}
              </select>
            </td>
            <td class="col-pl">${plinthsDisplay}${maxWarning}</td>
            <td class="col-step" style="text-align:center;color:#666;">${stepDisplay}</td>
            <td class="col-total ${totalClass}">${derived.totalHeight}</td>
            <td class="col-post">${postDisplay}</td>
            <td class="col-del"><button class="delete-panel-btn" onclick="app.deletePanel('${run.id}', ${idx})" title="Delete panel">&times;</button></td>
          </tr>`;
        }).join('');

        // Extension dropdown value mapping
        const extOptions = [
          { value: 'none', label: 'None' },
          { value: 'slat', label: 'Slat' },
          { value: 'solid_fill', label: 'Solid Fill' },
          { value: 'lattice', label: 'Lattice' }
        ];

        // Gates section
        const gatesHtml = (this.job.gates || []).map(gate => `
          <div class="gate-row">
            <select onchange="app.updateGate('${gate.id}', 'type', this.value)">
              <option value="pedestrian" ${gate.type === 'pedestrian' ? 'selected' : ''}>Pedestrian</option>
              <option value="double" ${gate.type === 'double' ? 'selected' : ''}>Double</option>
              <option value="sliding" ${gate.type === 'sliding' ? 'selected' : ''}>Sliding</option>
            </select>
            <input type="number" value="${gate.width}" min="600" step="100" style="width:70px;"
                   onchange="app.updateGate('${gate.id}', 'width', this.value)" placeholder="mm">
            <select onchange="app.updateGate('${gate.id}', 'runIndex', this.value)">
              ${this.job.runs.map((r, ri) =>
                `<option value="${ri}" ${gate.runIndex === ri ? 'selected' : ''}>${r.name}</option>`
              ).join('')}
            </select>
            <label style="font-size:11px;">After P</label>
            <input type="number" value="${gate.afterPanel}" min="1" max="${run.panels.length}" style="width:50px;"
                   onchange="app.updateGate('${gate.id}', 'afterPanel', this.value)">
            <button class="delete-panel-btn" onclick="app.deleteGate('${gate.id}')" title="Delete gate">&times;</button>
          </div>
        `).join('');

        document.getElementById('runContent').innerHTML = `
          ${warningsHtml}

          <div class="run-settings">
            <h3>Run Settings</h3>
            <div class="run-settings-grid">
              <div class="form-group">
                <label>Name</label>
                <input type="text" value="${run.name}"
                       onchange="app.updateRunSettings('${run.id}', 'name', this.value)">
              </div>
              <div class="form-group">
                <label>Length (m)</label>
                <input type="number" value="${run.length || ''}" min="0" step="0.5" placeholder="0.0"
                       onchange="app.updateRunSettings('${run.id}', 'length', this.value)">
              </div>
              <div class="form-group">
                <label>Sheet Height</label>
                <select onchange="app.updateRunSettings('${run.id}', 'sheetHeight', this.value)">
                  ${SHEET_HEIGHTS.map(h =>
                    `<option value="${h}" ${run.sheetHeight === h ? 'selected' : ''}>${h}mm</option>`
                  ).join('')}
                </select>
              </div>
              <div class="form-group">
                <label>Extension</label>
                <select onchange="app.updateRunSettings('${run.id}', 'extension', this.value)">
                  ${extOptions.map(o =>
                    `<option value="${o.value}" ${run.extension === o.value ? 'selected' : ''}>${o.label}</option>`
                  ).join('')}
                </select>
              </div>
            </div>
            <div class="run-settings-actions">
              <button class="btn-orange" onclick="app.applyHeightToAll('${run.id}')">Apply Height to All</button>
              <button class="btn-delete" onclick="app.deleteRun('${run.id}')">Delete Run</button>
            </div>
          </div>

          ${(() => {
            const slope = run.slope || {};
            const slopeMode = slope.mode || 'simple';
            const simple = slope.simple || { direction: 'left-to-right', totalFallMm: 0, startsFrom: 'start' };
            const slopePts = (slope.points) || [];
            const rid = run.id;
            const runLen = run.length || 0;

            if (slopeMode === 'simple') {
              // ── SIMPLE MODE ──
              const dirLR = simple.direction === 'left-to-right';
              const fall = simple.totalFallMm || 0;
              // Helper label
              let helperText = '';
              if (fall === 0) {
                helperText = 'Flat ground (no slope)';
              } else {
                const dirText = dirLR ? 'left to right' : 'right to left';
                const startLabels = { 'start': '', '25': ' from 25%', '50': ' from 50%', '75': ' from 75%' };
                helperText = 'Ground drops ' + fall + 'mm over ' + runLen.toFixed(1) + 'm (' + dirText + ')' + (startLabels[simple.startsFrom] || '');
              }

              return '<div class="slope-section">' +
                '<h3>Ground Slope</h3>' +
                '<div class="slope-simple-controls">' +
                  '<div class="slope-control-row">' +
                    '<label>Direction</label>' +
                    '<div class="slope-direction-toggle">' +
                      '<button class="slope-direction-btn' + (dirLR ? ' active' : '') + '" onclick="app.updateSimpleSlope(\'' + rid + '\', \'direction\', \'left-to-right\')">Falls left \u2192 right</button>' +
                      '<button class="slope-direction-btn' + (!dirLR ? ' active' : '') + '" onclick="app.updateSimpleSlope(\'' + rid + '\', \'direction\', \'right-to-left\')">Falls right \u2192 left</button>' +
                    '</div>' +
                  '</div>' +
                  '<div class="slope-control-row">' +
                    '<label>Total Fall</label>' +
                    '<input type="number" class="slope-fall-input-simple" value="' + fall + '" step="150" min="0" max="1800" ' +
                      'onchange="app.updateSimpleSlope(\'' + rid + '\', \'totalFallMm\', this.value)">' +
                    '<span style="font-size:12px;color:#6B5335;">mm</span>' +
                  '</div>' +
                  '<div class="slope-helper-label">' + helperText + '</div>' +
                  '<div class="slope-control-row">' +
                    '<label>Starts at</label>' +
                    '<select class="slope-starts-select" onchange="app.updateSimpleSlope(\'' + rid + '\', \'startsFrom\', this.value)">' +
                      '<option value="start"' + (simple.startsFrom === 'start' ? ' selected' : '') + '>From start</option>' +
                      '<option value="25"' + (simple.startsFrom === '25' ? ' selected' : '') + '>From 25%</option>' +
                      '<option value="50"' + (simple.startsFrom === '50' ? ' selected' : '') + '>From 50%</option>' +
                      '<option value="75"' + (simple.startsFrom === '75' ? ' selected' : '') + '>From 75%</option>' +
                    '</select>' +
                  '</div>' +
                '</div>' +
                '<a class="slope-mode-link" onclick="app.toggleSlopeMode(\'' + rid + '\')">Advanced mode \u2192</a>' +
              '</div>';
            } else {
              // ── ADVANCED MODE ──
              const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
              let slopeRows = '';
              slopePts.forEach((pt, pi) => {
                const letter = pi < letters.length ? letters[pi] : '?';
                const hMm = pt.heightMm || 0;
                const userFlag = pt.userSet ? ' \u2022' : '';

                if (pi === 0) {
                  // Point A — UNLOCKED in advanced mode
                  slopeRows += '<div class="slope-point-row">' +
                    '<span class="slope-pt-label">' + letter + '</span>' +
                    '<span>' + letter + ' \u2014 Start (0m) \u2014 height</span>' +
                    '<input type="number" class="slope-fall-input" value="' + hMm + '" step="50" ' +
                    'onchange="app.updateSlopePoint(\'' + rid + '\', 0, \'heightMm\', this.value)">' +
                    '<span>mm' + userFlag + '</span>' +
                    '</div>';
                } else if (pi === slopePts.length - 1) {
                  // End point
                  slopeRows += '<div class="slope-point-row">' +
                    '<span class="slope-pt-label">' + letter + '</span>' +
                    '<span>' + letter + ' \u2014 End (' + pt.distanceM.toFixed(1) + 'm) \u2014 height</span>' +
                    '<input type="number" class="slope-fall-input" value="' + hMm + '" step="50" ' +
                    'onchange="app.updateSlopePoint(\'' + rid + '\', ' + pi + ', \'heightMm\', this.value)">' +
                    '<span>mm' + userFlag + '</span>' +
                    '</div>';
                } else {
                  // Intermediate point
                  slopeRows += '<div class="slope-point-row">' +
                    '<span class="slope-pt-label">' + letter + '</span>' +
                    '<span>' + letter + ' \u2014</span>' +
                    '<input type="number" class="slope-dist-input" value="' + pt.distanceM.toFixed(1) + '" step="0.5" min="0.5" max="' + (runLen - 0.5) + '" ' +
                    'onchange="app.updateSlopePoint(\'' + rid + '\', ' + pi + ', \'distanceM\', this.value)">' +
                    '<span>m \u2014 height</span>' +
                    '<input type="number" class="slope-fall-input" value="' + hMm + '" step="50" ' +
                    'onchange="app.updateSlopePoint(\'' + rid + '\', ' + pi + ', \'heightMm\', this.value)">' +
                    '<span>mm' + userFlag + '</span>' +
                    '<button class="slope-point-delete" onclick="app.removeSlopePoint(\'' + rid + '\', ' + pi + ')" title="Remove point">&times;</button>' +
                    '</div>';
                }
              });

              const monoLabel = slope.monotonic === 'falling' ? ' (falling)' : (slope.monotonic === 'rising' ? ' (rising)' : '');

              return '<div class="slope-section">' +
                '<h3>Ground Slope \u2014 Advanced' + monoLabel + '</h3>' +
                '<div class="slope-hint">Drag points in the profile view or edit heights directly. Monotonic direction is enforced. Waterfall: subsequent unset points auto-follow.</div>' +
                '<div class="slope-point-list">' + slopeRows + '</div>' +
                '<div class="slope-actions">' +
                '<button class="btn-slope" onclick="app.addSlopePoint(\'' + rid + '\')">+ Add Point</button>' +
                '<button class="btn-slope" onclick="app.resetSlope(\'' + rid + '\')" style="background:#A0895F;">Reset Flat</button>' +
                '</div>' +
                '<a class="slope-mode-link" onclick="app.toggleSlopeMode(\'' + rid + '\')">\u2190 Simple mode</a>' +
              '</div>';
            }
          })()}

          <div class="quick-retaining">
            <h3>Quick Retaining Tool</h3>
            <div class="quick-retaining-row">
              <div class="form-group">
                <label>From Panel</label>
                <input type="number" id="qr-start-${run.id}" min="1" max="${run.panels.length}" value="1" style="width:60px;">
              </div>
              <div class="form-group">
                <label>To Panel</label>
                <input type="number" id="qr-end-${run.id}" min="1" max="${run.panels.length}" value="${run.panels.length}" style="width:60px;">
              </div>
              <div class="form-group">
                <label>Retaining (mm)</label>
                <select id="qr-retaining-${run.id}">
                  ${RETAINING_OPTIONS.map(r =>
                    `<option value="${r}">${r}</option>`
                  ).join('')}
                </select>
              </div>
              <button class="btn-orange" onclick="app.applyQuickRetaining('${run.id}')">Apply</button>
            </div>
          </div>

          <div class="panel-table-section">
            <h3>Panel Table</h3>
            <div class="panel-table-wrap">
              <table class="panel-table">
                <thead>
                  <tr>
                    <th>P#</th>
                    <th>Sheet Ht</th>
                    <th title="Slope-generated plinths (auto)">Slope</th>
                    <th title="Manual retaining (mm)">Ret (mm)</th>
                    <th>Plinths</th>
                    <th>Step</th>
                    <th>Total</th>
                    <th>Post</th>
                    <th>&times;</th>
                  </tr>
                </thead>
                <tbody>
                  ${panelRows}
                </tbody>
              </table>
            </div>
          </div>

          <div class="gates-section">
            <h3>Gates</h3>
            ${gatesHtml || '<p style="font-size:12px; color:#4C6A70;">No gates added.</p>'}
            <button class="btn-orange" style="margin-top:8px;" onclick="app.addGate()">+ Add Gate</button>
          </div>

          <div class="job-settings-section">
            <button class="job-settings-toggle" onclick="app.toggleJobSettings()">
              <span>Job Settings &amp; Scope</span>
              <span class="toggle-arrow ${this._jobSettingsOpen ? 'open' : ''}" id="jsToggleArrow">&#9654;</span>
            </button>
            <div class="job-settings-body ${this._jobSettingsOpen ? '' : 'collapsed'}" id="jsBody">
              <div class="js-row">
                <div class="form-group">
                  <label>Access Difficulty</label>
                  <select id="jsAccess" onchange="app.saveJobSettings()">
                    <option value="easy">Easy</option>
                    <option value="moderate">Moderate</option>
                    <option value="difficult">Difficult</option>
                  </select>
                </div>
                <div class="form-group">
                  <label>Urgency</label>
                  <select id="jsUrgency" onchange="app.saveJobSettings()">
                    <option value="standard">Standard</option>
                    <option value="urgent">Urgent</option>
                    <option value="rush">Rush</option>
                    <option value="emergency">Emergency</option>
                  </select>
                </div>
                <div class="form-group">
                  <label>Delivery Fee ($)</label>
                  <input type="number" id="jsDelivery" value="250" min="0" step="10" onchange="app.saveJobSettings()">
                </div>
              </div>

              <div class="js-label">Optional Items</div>

              <div class="js-opt-row">
                <input type="checkbox" id="jsRemoveHardie" onchange="app.saveJobSettings()">
                <label for="jsRemoveHardie">Remove Hardie sheets</label>
                <input type="number" id="jsRemoveHardieQty" value="0" min="0" style="width:50px;" onchange="app.saveJobSettings()">
                <span style="font-size:11px;color:#666;">qty</span>
              </div>
              <div class="js-opt-row">
                <input type="checkbox" id="jsRemoveTimber" onchange="app.saveJobSettings()">
                <label for="jsRemoveTimber">Remove timber lap</label>
                <input type="number" id="jsRemoveTimberQty" value="0" min="0" step="0.5" style="width:50px;" onchange="app.saveJobSettings()">
                <span style="font-size:11px;color:#666;">metres</span>
              </div>
              <div class="js-opt-row">
                <input type="checkbox" id="jsRemoveAsbestos" onchange="app.saveJobSettings()">
                <label for="jsRemoveAsbestos">Remove asbestos sheets</label>
                <input type="number" id="jsRemoveAsbestosQty" value="0" min="0" style="width:50px;" onchange="app.saveJobSettings()">
                <span style="font-size:11px;color:#666;">qty</span>
              </div>
              <div class="js-opt-row">
                <input type="checkbox" id="jsVegClear" onchange="app.saveJobSettings()">
                <label for="jsVegClear">Vegetation / site clear ($150 flat)</label>
              </div>
              <div class="js-opt-row">
                <input type="checkbox" id="jsPedGate" onchange="app.saveJobSettings()">
                <label for="jsPedGate">Pedestrian gate</label>
                <input type="number" id="jsPedGateQty" value="1" min="1" style="width:50px;" onchange="app.saveJobSettings()">
                <span style="font-size:11px;color:#666;">qty</span>
              </div>
              <div class="js-opt-row">
                <input type="checkbox" id="jsDblGate" onchange="app.saveJobSettings()">
                <label for="jsDblGate">Double swing gate</label>
                <input type="number" id="jsDblGateQty" value="1" min="1" style="width:50px;" onchange="app.saveJobSettings()">
                <span style="font-size:11px;color:#666;">qty</span>
              </div>
              <div class="js-opt-row">
                <label for="jsGroundFinish" style="margin-right:4px;">Ground finish:</label>
                <select id="jsGroundFinish" onchange="app.saveJobSettings()">
                  <option value="none">None</option>
                  <option value="mulch">Mulch</option>
                  <option value="stones">Stones</option>
                  <option value="turf">Turf</option>
                </select>
              </div>

              <div class="js-label">Custom Line Items</div>
              ${[0,1,2].map(ci => `
              <div class="js-opt-row">
                <input type="text" class="js-desc-input" id="jsCustomDesc${ci}" placeholder="Description" onchange="app.saveJobSettings()">
                <input type="number" id="jsCustomQty${ci}" value="0" min="0" style="width:50px;" placeholder="Qty" onchange="app.saveJobSettings()">
                <input type="text" class="js-unit-input" id="jsCustomUnit${ci}" placeholder="unit" onchange="app.saveJobSettings()">
                <span style="font-size:11px;">$</span>
                <input type="number" class="js-price-input" id="jsCustomPrice${ci}" value="0" min="0" step="1" placeholder="Price" onchange="app.saveJobSettings()">
              </div>`).join('')}

              <div class="js-label">Special Notes</div>
              <textarea class="js-notes" id="jsNotes" placeholder="Site access notes, special instructions..." onchange="app.saveJobSettings()"></textarea>
            </div>
          </div>
        `;
      },

      // ── View switching ──
      currentView: 'profile',

      switchView(view) {
        this.currentView = view;
        const tabs = document.querySelectorAll('.view-tab');
        tabs[0].classList.toggle('active', view === 'profile');
        tabs[1].classList.toggle('active', view === '3d');
        document.getElementById('profileViewContainer').style.display = view === 'profile' ? '' : 'none';
        document.getElementById('threeDPlaceholder').style.display = view === '3d' ? '' : 'none';
      },

      // ── Profile View: pan/zoom state ──
      profilePan: { x: 0, y: 0 },
      profileZoom: 1,
      _profileDrag: null,
      _profileHitRegions: [],
      _profileHover: null,
      highlightedPanelIdx: null,

      // ── Soil profile handle dragging state (retaining handles — per-panel, orange) ──
      _soilHandlePositions: [],    // [{x, y, postIdx}] world coords of each handle
      _soilHandleDrag: null,       // {postIdx, startY, startRetLeft, startRetRight} when dragging
      _soilHandleHover: -1,        // index of hovered handle, -1 if none
      _soilHandleProximity: false,  // true when mouse is near ground line
      _soilGroundOffsets: [],       // cached ground offsets in mm for handle drag calculations

      // ── Slope point state (variable control points) ──
      _slopePointPositions: [],   // [{x, y, pointIdx}] world coords of slope points
      _slopePointDrag: null,      // {pointIdx, startWorldY} when dragging
      _slopePointHover: -1,       // index of hovered slope point

      // Select a panel (from table click or canvas click)
      selectPanel(idx) {
        this.highlightedPanelIdx = (this.highlightedPanelIdx === idx) ? null : idx;
        this.renderProfileView();
        // Update table row highlights without full re-render
        const rows = document.querySelectorAll('.panel-table tbody tr[data-panel-idx]');
        rows.forEach(row => {
          const ri = parseInt(row.getAttribute('data-panel-idx'));
          row.classList.toggle('panel-row-highlight', ri === this.highlightedPanelIdx);
        });
        // Scroll the selected row into view
        if (this.highlightedPanelIdx !== null) {
          const sel = document.querySelector(`.panel-table tbody tr[data-panel-idx="${this.highlightedPanelIdx}"]`);
          if (sel) sel.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        }
      },

      // Convert screen mouse coords to canvas world coords (accounting for pan/zoom)
      _screenToWorld(clientX, clientY) {
        const container = document.getElementById('profileViewContainer');
        if (!container) return { x: 0, y: 0 };
        const rect = container.getBoundingClientRect();
        const sx = clientX - rect.left;
        const sy = clientY - rect.top;
        const wx = (sx - this.profilePan.x) / this.profileZoom;
        const wy = (sy - this.profilePan.y) / this.profileZoom;
        return { x: wx, y: wy };
      },

      // Hit test: find which region the world coord falls in
      _hitTest(wx, wy) {
        // Test in reverse order so topmost drawn items match first
        for (let i = this._profileHitRegions.length - 1; i >= 0; i--) {
          const r = this._profileHitRegions[i];
          if (r.shape === 'rect') {
            if (wx >= r.x && wx <= r.x + r.w && wy >= r.y && wy <= r.y + r.h) return r;
          } else if (r.shape === 'circle') {
            const dx = wx - r.cx, dy = wy - r.cy;
            if (dx * dx + dy * dy <= r.r * r.r) return r;
          }
        }
        return null;
      },

      // Check if world coords are near a soil handle; returns index or -1
      _hitTestSoilHandle(wx, wy) {
        const isTouchDevice = 'ontouchstart' in window;
        // Handle is drawn at (handleR / zoom) world units; use a generous hit area
        const baseR = isTouchDevice ? 12 : 8;
        const worldR = (baseR + 4) / this.profileZoom; // slightly larger than visual for easy grabbing
        for (let i = 0; i < this._soilHandlePositions.length; i++) {
          const h = this._soilHandlePositions[i];
          const dx = wx - h.x, dy = wy - h.y;
          if (dx * dx + dy * dy <= worldR * worldR) return i;
        }
        return -1;
      },

      // Check if world Y is within proximity of the soil profile line
      _isNearSoilProfile(wx, wy) {
        const proximityPx = 30 / this.profileZoom;
        for (let i = 0; i < this._soilHandlePositions.length; i++) {
          const h = this._soilHandlePositions[i];
          if (Math.abs(wy - h.y) < proximityPx && Math.abs(wx - h.x) < proximityPx * 3) return true;
        }
        return false;
      },

      // Check if world coords are near a slope point; returns index or -1
      _hitTestSlopePoint(wx, wy) {
        const baseR = 12;
        const worldR = (baseR + 4) / this.profileZoom;
        for (let i = 0; i < this._slopePointPositions.length; i++) {
          const h = this._slopePointPositions[i];
          const dx = wx - h.x, dy = wy - h.y;
          if (dx * dx + dy * dy <= worldR * worldR) return i;
        }
        return -1;
      },

      // Apply slope point drag: update point heightMm from canvas drag
      // Advanced mode only. Point A unlocked. Monotonic + waterfall enforced.
      _applySlopePointDrag(pointIdx, worldY) {
        const run = this.job.runs.find(r => r.id === this.currentRunId);
        if (!run || !run.slope) return;
        // Block dragging in simple mode
        if (run.slope.mode === 'simple') return;
        const pts = run.slope.points;
        if (!pts[pointIdx]) return;
        const layout = this._soilHandleLayout;
        if (!layout) return;

        const rawMm = (layout.groundY - worldY) / layout.scale;
        let snapped = Math.max(-2400, Math.min(2400, Math.round(rawMm / 50) * 50));

        // Determine monotonic direction on first drag
        const prevHeight = pts[pointIdx].heightMm;
        if (run.slope.monotonic === null && snapped !== prevHeight) {
          run.slope.monotonic = snapped < prevHeight ? 'falling' : 'rising';
        }

        // Enforce monotonic: this point must be consistent with previous
        if (pointIdx > 0 && run.slope.monotonic === 'falling') {
          snapped = Math.min(snapped, pts[pointIdx - 1].heightMm);
        } else if (pointIdx > 0 && run.slope.monotonic === 'rising') {
          snapped = Math.max(snapped, pts[pointIdx - 1].heightMm);
        }

        pts[pointIdx].heightMm = snapped;
        pts[pointIdx].userSet = true;

        // Waterfall: auto-adjust subsequent non-userSet points
        for (let i = pointIdx + 1; i < pts.length; i++) {
          if (!pts[i].userSet) {
            pts[i].heightMm = snapped;
          } else {
            // Enforce monotonic on userSet subsequent points too
            if (run.slope.monotonic === 'falling') {
              pts[i].heightMm = Math.min(pts[i].heightMm, pts[i - 1].heightMm);
            } else if (run.slope.monotonic === 'rising') {
              pts[i].heightMm = Math.max(pts[i].heightMm, pts[i - 1].heightMm);
            }
          }
        }

        this.calcSlopeForRun(run);
      },

      _showSlopePointTooltip(clientX, clientY, pointIdx) {
        const run = this.job.runs.find(r => r.id === this.currentRunId);
        if (!run || !run.slope) return;
        const container = document.getElementById('profileViewContainer');
        const tooltip = document.getElementById('soilHandleTooltip');
        if (!tooltip || !container) return;

        const pts = run.slope.points;
        if (!pts[pointIdx]) return;
        const mm = pts[pointIdx].heightMm || 0;
        let text;
        if (mm === 0) {
          text = '0mm (level)';
        } else if (mm < 0) {
          text = `Falls ${Math.abs(mm)}mm`;
        } else {
          text = `Rises ${mm}mm`;
        }

        const rect = container.getBoundingClientRect();
        tooltip.textContent = text;
        tooltip.style.display = 'block';
        tooltip.style.background = 'rgba(139,115,85,0.95)';
        tooltip.style.left = (clientX - rect.left + 14) + 'px';
        tooltip.style.top = (clientY - rect.top - 34) + 'px';
      },

      // Apply retaining handle drag: update ONE panel's retaining from handle position
      // Retaining is capped so that total plinths (slope + manual) ≤ 4
      _applySoilHandleDrag(panelIdx, worldY) {
        const run = this.job.runs.find(r => r.id === this.currentRunId);
        if (!run || panelIdx < 0 || panelIdx >= run.panels.length) return;

        const plinthHeightMm = 150;
        const layout = this._soilHandleLayout;
        if (!layout) return;

        // handle going UP (smaller worldY) = more retaining
        const lowOff = Math.max(layout.groundOffsets[panelIdx], layout.groundOffsets[panelIdx + 1]);
        const lowGndY = layout.groundY + lowOff * layout.scale;
        const rawRetMm = (lowGndY - worldY) / layout.scale;
        const snapped = Math.round(rawRetMm / plinthHeightMm) * plinthHeightMm;
        run.panels[panelIdx].retaining = Math.max(0, Math.min(600, snapped));
      },

      // Show the retaining handle drag tooltip
      _showSoilHandleTooltip(clientX, clientY, panelIdx) {
        const run = this.job.runs.find(r => r.id === this.currentRunId);
        if (!run || panelIdx < 0 || panelIdx >= run.panels.length) return;
        const container = document.getElementById('profileViewContainer');
        const tooltip = document.getElementById('soilHandleTooltip');
        if (!tooltip || !container) return;

        const retMm = run.panels[panelIdx].retaining;
        const plinths = retMm / 150;
        let text;
        if (retMm === 0) {
          text = '0mm (no retaining)';
        } else {
          text = `+${retMm}mm (${plinths} plinth${plinths !== 1 ? 's' : ''})`;
        }

        const rect = container.getBoundingClientRect();
        tooltip.textContent = text;
        tooltip.style.display = 'block';
        tooltip.style.background = 'rgba(241,90,41,0.92)';
        tooltip.style.left = (clientX - rect.left + 14) + 'px';
        tooltip.style.top = (clientY - rect.top - 34) + 'px';
      },

      _hideSoilHandleTooltip() {
        const tooltip = document.getElementById('soilHandleTooltip');
        if (tooltip) tooltip.style.display = 'none';
      },

      initProfileViewControls() {
        const container = document.getElementById('profileViewContainer');
        if (!container || container._pvBound) return;
        container._pvBound = true;

        const isTouchDevice = 'ontouchstart' in window;

        container.addEventListener('mousedown', (e) => {
          const w = this._screenToWorld(e.clientX, e.clientY);

          // Check slope points (variable ground profile) — advanced mode only
          const curRun = this.job.runs.find(r => r.id === this.currentRunId);
          if (curRun && curRun.slope && curRun.slope.mode === 'advanced') {
            const slopeIdx = this._hitTestSlopePoint(w.x, w.y);
            if (slopeIdx >= 0) {
              e.preventDefault();
              e.stopPropagation();
              this._slopePointDrag = { pointIdx: slopeIdx, startWorldY: w.y, active: true };
              this._slopePointHover = slopeIdx;
              container.style.cursor = 'ns-resize';
              this._showSlopePointTooltip(e.clientX, e.clientY, slopeIdx);
              return;
            }
          }

          // Check retaining handles (per-panel)
          const handleIdx = this._hitTestSoilHandle(w.x, w.y);
          if (handleIdx >= 0) {
            e.preventDefault();
            e.stopPropagation();
            const run = this.job.runs.find(r => r.id === this.currentRunId);
            if (!run) return;
            this._soilHandleDrag = {
              panelIdx: handleIdx,
              startWorldY: w.y,
              active: true
            };
            this._soilHandleHover = handleIdx;
            container.style.cursor = 'ns-resize';
            this._showSoilHandleTooltip(e.clientX, e.clientY, handleIdx);
            return;
          }

          this._profileDrag = { startX: e.clientX, startY: e.clientY, panX: this.profilePan.x, panY: this.profilePan.y, moved: false };
        });

        window.addEventListener('mousemove', (e) => {
          // Slope point drag in progress
          if (this._slopePointDrag && this._slopePointDrag.active) {
            const w = this._screenToWorld(e.clientX, e.clientY);
            this._applySlopePointDrag(this._slopePointDrag.pointIdx, w.y);
            this._showSlopePointTooltip(e.clientX, e.clientY, this._slopePointDrag.pointIdx);
            this.renderProfileView();
            this._syncPanelTableRetaining();
            return;
          }

          // Retaining handle drag in progress
          if (this._soilHandleDrag && this._soilHandleDrag.active) {
            const w = this._screenToWorld(e.clientX, e.clientY);
            this._applySoilHandleDrag(this._soilHandleDrag.panelIdx, w.y);
            this._showSoilHandleTooltip(e.clientX, e.clientY, this._soilHandleDrag.panelIdx);
            this.renderProfileView();
            // Sync panel table retaining dropdowns without full re-render
            this._syncPanelTableRetaining();
            return;
          }

          // Pan drag in progress
          if (this._profileDrag) {
            const dx = e.clientX - this._profileDrag.startX;
            const dy = e.clientY - this._profileDrag.startY;
            if (Math.abs(dx) > 3 || Math.abs(dy) > 3) this._profileDrag.moved = true;
            this.profilePan.x = this._profileDrag.panX + dx * 0.6;
            this.profilePan.y = this._profileDrag.panY + dy * 0.6;
            this.renderProfileView();
            return;
          }

          // Hover: check slope handles, retaining handles, and hit regions
          const w = this._screenToWorld(e.clientX, e.clientY);

          // Slope point hover — advanced mode only
          const hoverRun = this.job.runs.find(r => r.id === this.currentRunId);
          const slopeHoverIdx = (hoverRun && hoverRun.slope && hoverRun.slope.mode === 'advanced') ? this._hitTestSlopePoint(w.x, w.y) : -1;
          if (slopeHoverIdx >= 0) {
            this._slopePointHover = slopeHoverIdx;
            container.style.cursor = 'ns-resize';
            this._showSlopePointTooltip(e.clientX, e.clientY, slopeHoverIdx);
            if (this._soilHandleHover >= 0) { this._soilHandleHover = -1; }
            if (this._profileHover) { this._profileHover = null; const pvT = document.getElementById('pvTooltip'); if (pvT) pvT.style.display = 'none'; }
            this.renderProfileView();
            return;
          } else if (this._slopePointHover >= 0) {
            this._slopePointHover = -1;
            this._hideSoilHandleTooltip();
            this.renderProfileView();
          }

          // Retaining handle hover
          const handleIdx = this._hitTestSoilHandle(w.x, w.y);
          const nearSoil = this._isNearSoilProfile(w.x, w.y);

          if (handleIdx >= 0) {
            this._soilHandleHover = handleIdx;
            this._soilHandleProximity = true;
            container.style.cursor = 'ns-resize';
            this._showSoilHandleTooltip(e.clientX, e.clientY, handleIdx);
            if (this._profileHover) {
              this._profileHover = null;
              const pvTooltip = document.getElementById('pvTooltip');
              if (pvTooltip) pvTooltip.style.display = 'none';
            }
            this.renderProfileView();
            return;
          } else if (this._soilHandleHover >= 0) {
            this._soilHandleHover = -1;
            this._hideSoilHandleTooltip();
            this.renderProfileView();
          }

          // Track proximity to soil line (show/hide retaining handles)
          const wasNear = this._soilHandleProximity;
          this._soilHandleProximity = nearSoil;
          if (wasNear !== nearSoil) this.renderProfileView();

          // Standard hover hit-testing
          const hit = this._hitTest(w.x, w.y);
          const tooltip = document.getElementById('pvTooltip');
          if (hit) {
            this._profileHover = hit;
            if (tooltip) {
              const rect = container.getBoundingClientRect();
              tooltip.textContent = hit.label;
              tooltip.style.display = 'block';
              tooltip.style.left = (e.clientX - rect.left + 12) + 'px';
              tooltip.style.top = (e.clientY - rect.top - 28) + 'px';
            }
            container.style.cursor = 'pointer';
            this.renderProfileView();
          } else if (this._profileHover) {
            this._profileHover = null;
            if (tooltip) tooltip.style.display = 'none';
            if (!nearSoil) container.style.cursor = 'grab';
            this.renderProfileView();
          } else if (!nearSoil) {
            container.style.cursor = 'grab';
          }
        });

        window.addEventListener('mouseup', (e) => {
          if (this._slopePointDrag && this._slopePointDrag.active) {
            // Finish slope point drag — save and do full re-render
            this._slopePointDrag = null;
            this._hideSoilHandleTooltip();
            container.style.cursor = 'grab';
            this.save();
            this.render();
            return;
          }
          if (this._soilHandleDrag && this._soilHandleDrag.active) {
            // Finish retaining handle drag — save and do full re-render
            this._soilHandleDrag = null;
            this._hideSoilHandleTooltip();
            container.style.cursor = 'grab';
            this.save();
            this.render();
            return;
          }
          if (this._profileDrag && !this._profileDrag.moved) {
            // Click — check for panel number circle hit
            const w = this._screenToWorld(e.clientX, e.clientY);
            const hit = this._hitTest(w.x, w.y);
            if (hit && hit.type === 'circle') {
              this.selectPanel(hit.panelIdx);
            }
          }
          this._profileDrag = null;
        });

        // Touch support for slope points + retaining handles
        container.addEventListener('touchstart', (e) => {
          if (e.touches.length !== 1) return;
          const touch = e.touches[0];
          const w = this._screenToWorld(touch.clientX, touch.clientY);

          // Slope points (variable ground profile) — advanced mode only
          const curRunT = this.job.runs.find(r => r.id === this.currentRunId);
          if (curRunT && curRunT.slope && curRunT.slope.mode === 'advanced') {
            const slopeIdx = this._hitTestSlopePoint(w.x, w.y);
            if (slopeIdx >= 0) {
              e.preventDefault();
              this._slopePointDrag = { pointIdx: slopeIdx, startWorldY: w.y, active: true, isTouch: true };
              this._slopePointHover = slopeIdx;
              this._showSlopePointTooltip(touch.clientX, touch.clientY, slopeIdx);
              this.renderProfileView();
              return;
            }
          }

          // Retaining handles
          const handleIdx = this._hitTestSoilHandle(w.x, w.y);
          if (handleIdx >= 0) {
            e.preventDefault();
            this._soilHandleDrag = { panelIdx: handleIdx, startWorldY: w.y, active: true, isTouch: true };
            this._soilHandleHover = handleIdx;
            this._showSoilHandleTooltip(touch.clientX, touch.clientY, handleIdx);
            this.renderProfileView();
          }
        }, { passive: false });

        container.addEventListener('touchmove', (e) => {
          if (this._slopePointDrag && this._slopePointDrag.active && this._slopePointDrag.isTouch) {
            e.preventDefault();
            const touch = e.touches[0];
            const w = this._screenToWorld(touch.clientX, touch.clientY);
            this._applySlopePointDrag(this._slopePointDrag.pointIdx, w.y);
            this._showSlopePointTooltip(touch.clientX, touch.clientY, this._slopePointDrag.pointIdx);
            this.renderProfileView();
            this._syncPanelTableRetaining();
            return;
          }
          if (this._soilHandleDrag && this._soilHandleDrag.active && this._soilHandleDrag.isTouch) {
            e.preventDefault();
            const touch = e.touches[0];
            const w = this._screenToWorld(touch.clientX, touch.clientY);
            this._applySoilHandleDrag(this._soilHandleDrag.panelIdx, w.y);
            this._showSoilHandleTooltip(touch.clientX, touch.clientY, this._soilHandleDrag.panelIdx);
            this.renderProfileView();
            this._syncPanelTableRetaining();
          }
        }, { passive: false });

        container.addEventListener('touchend', (e) => {
          if (this._slopePointDrag && this._slopePointDrag.active && this._slopePointDrag.isTouch) {
            this._slopePointDrag = null;
            this._hideSoilHandleTooltip();
            this.save();
            this.render();
            return;
          }
          if (this._soilHandleDrag && this._soilHandleDrag.active && this._soilHandleDrag.isTouch) {
            this._soilHandleDrag = null;
            this._hideSoilHandleTooltip();
            this.save();
            this.render();
          }
        });

        container.addEventListener('wheel', (e) => {
          e.preventDefault();
          const delta = e.deltaY > 0 ? 0.95 : 1.05;
          const rect = container.getBoundingClientRect();
          const mx = e.clientX - rect.left;
          const my = e.clientY - rect.top;
          this.profilePan.x = mx - (mx - this.profilePan.x) * delta;
          this.profilePan.y = my - (my - this.profilePan.y) * delta;
          this.profileZoom *= delta;
          this.profileZoom = Math.max(0.5, Math.min(5, this.profileZoom));
          this.renderProfileView();
        }, { passive: false });
      },

      // Sync panel table retaining dropdowns to match current panel data (no full re-render)
      _syncPanelTableRetaining() {
        const run = this.job.runs.find(r => r.id === this.currentRunId);
        if (!run) return;
        const dragIdx = this._soilHandleDrag ? this._soilHandleDrag.panelIdx : -1;
        const rows = document.querySelectorAll('.panel-table tbody tr[data-panel-idx]');
        rows.forEach(row => {
          const idx = parseInt(row.getAttribute('data-panel-idx'));
          if (idx >= 0 && idx < run.panels.length) {
            const panel = run.panels[idx];
            const derived = this.getPanelDerived(panel);

            // Update slope plinths display
            const slopeTd = row.querySelector('.col-slope');
            if (slopeTd) {
              slopeTd.textContent = derived.slopePlinths > 0 ? `${derived.slopePlinths}` : '—';
            }

            const sel = row.querySelector('.col-ret select');
            if (sel && parseInt(sel.value) !== panel.retaining) {
              sel.value = panel.retaining;
            }

            // Update plinths display (total, capped at 4)
            const plTd = row.querySelector('.col-pl');
            if (plTd) {
              const maxW = derived.plinthsCapped
                ? ' <span title="Max plinth capacity" style="color:#e65100;font-weight:700;">\u26A0</span>'
                : (derived.plinths >= 4 ? ' <span title="Max retaining" style="color:#e65100;font-weight:700;">\u26A0</span>' : '');
              plTd.innerHTML = (derived.plinths >= 3 ? `${derived.plinths}\u2020` : `${derived.plinths}`) + maxW;
            }

            // Update step display with mm amount
            const stepTd = row.querySelector('.col-step');
            if (stepTd) {
              const stepMm = panel.stepMm || 0;
              if (stepMm < 0) stepTd.textContent = '\u2193' + Math.abs(stepMm);
              else if (stepMm > 0) stepTd.textContent = '\u2191' + stepMm;
              else stepTd.textContent = '\u2014';
            }

            // Update total display
            const totTd = row.querySelector('.col-total');
            if (totTd) {
              const total = derived.totalHeight;
              totTd.textContent = total;
              totTd.className = 'col-total ' + (total > 1800 ? 'total-elevated' : 'total-standard');
            }
            // Update post display
            const postTd = row.querySelector('.col-post');
            if (postTd) {
              const posts = this.getRunPosts(run);
              const leftPost = posts[idx];
              const rightPost = posts[idx + 1];
              const maxPost = Math.max(leftPost.postSize, rightPost.postSize);
              const anyPatio = leftPost.patio || rightPost.patio;
              postTd.innerHTML = anyPatio ? `<span class="post-patio">${maxPost}†</span>` : `${maxPost}`;
            }
            // Highlight dragged panel during handle drag
            row.style.background = (dragIdx === idx) ? 'rgba(241,90,41,0.10)' : '';
          }
        });
      },

      // ── Profile View: main render ──
      // Panel texture image (loaded from file, cached)
      _panelTextureImg: null,
      _panelTextureLoaded: false,

      // Source crop rectangles from textures/panel_harmony_surfmist.png (2816x1536)
      // Posts: left x=327..389 (63px), right x=2426..2489 (64px)
      // Cap rail: y=51..92 (42px high)
      // Sheet: x=390..2425, y=93..1436 (2036w x 1344h)
      // Bottom rail: y=1437..1482 (46px high)
      SRC_SHEET: { sx: 390, sy: 93, sw: 2036, sh: 1344 },
      SRC_CAP:   { sx: 390, sy: 51, sw: 2036, sh: 42 },
      SRC_RAIL:  { sx: 390, sy: 1437, sw: 2036, sh: 46 },

      _loadPanelTexture() {
        const img = new Image();
        img.onload = () => {
          console.log('Panel texture loaded OK:', img.naturalWidth, 'x', img.naturalHeight);
          this._panelTextureImg = img;
          this._panelTextureLoaded = true;
          this.renderProfileView();
        };
        img.onerror = (e) => {
          console.error('Panel texture FAILED to load:', e);
        };
        img.src = 'textures/panel_harmony_surfmist.png';
      },

      // Track the last run ID we auto-fitted, so we re-fit when switching runs
      _lastFittedRunId: null,

      resetProfileView() {
        this.profilePan = { x: 0, y: 0 };
        this.profileZoom = 1;
        this._lastFittedRunId = null; // force re-fit
        this.renderProfileView();
      },

      renderProfileView() {
        const container = document.getElementById('profileViewContainer');
        const canvas = document.getElementById('profileCanvas');
        if (!container || !canvas) return;

        this.initProfileViewControls();

        const cw = container.clientWidth;
        const ch = container.clientHeight;
        if (cw === 0 || ch === 0) return;

        canvas.width = cw;
        canvas.height = ch;
        const ctx = canvas.getContext('2d');

        // Background
        ctx.fillStyle = '#f0f4f8';
        ctx.fillRect(0, 0, cw, ch);

        const run = this.job.runs.find(r => r.id === this.currentRunId);
        if (!run || run.panels.length === 0) {
          ctx.fillStyle = '#4C6A70';
          ctx.font = '18px Helvetica Neue, Helvetica, Arial, sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('No panels — add a run and set its length', cw / 2, ch / 2);
          return;
        }

        // ── Colour lookup ──
        const allColours = [...COLOURS_STOCK, ...COLOURS_SPECIAL];
        const colourEntry = allColours.find(c => c.name === this.job.colour) || { hex: '#BDBFBA' };
        const fenceHex = colourEntry.hex;

        function darkenHex(hex, factor) {
          const r = parseInt(hex.slice(1, 3), 16);
          const g = parseInt(hex.slice(3, 5), 16);
          const b = parseInt(hex.slice(5, 7), 16);
          return `rgb(${Math.round(Math.min(255, r * factor))},${Math.round(Math.min(255, g * factor))},${Math.round(Math.min(255, b * factor))})`;
        }

        // Total retaining per panel (slope plinths + manual retaining), capped at 4 plinths (600mm)
        function panelTotalRetaining(p) {
          const raw = (p.slopePlinths || 0) * 150 + p.retaining;
          return Math.min(600, raw); // cap at 4 plinths
        }

        // ── Dimensions in mm ──
        const panelCount = run.panels.length;
        const postCount = panelCount + 1;
        const panelWidthMm = this.getPanelWidthMm();
        const postWidthMm = 50;
        const patioWidthMm = 120;  // visual only, does not affect layout spacing
        const embedDepthMm = 600;
        const railHeightMm = 25;
        const plinthHeightMm = 150;

        let maxTotalH = 0;
        run.panels.forEach(p => {
          const th = p.height + panelTotalRetaining(p);
          if (th > maxTotalH) maxTotalH = th;
        });

        // ── Ground offsets from step amounts (variable per panel) ──
        const groundOffsets = new Array(postCount).fill(0);
        for (let i = 0; i < panelCount; i++) {
          const stepMm = run.panels[i].stepMm || 0;
          // stepMm negative = step down = ground lower → offset increases
          // stepMm positive = step up = ground higher → offset decreases
          groundOffsets[i + 1] = groundOffsets[i] - stepMm;
        }
        const minGndOffset = Math.min(...groundOffsets);
        for (let i = 0; i < groundOffsets.length; i++) groundOffsets[i] -= minGndOffset;
        const maxGndOffset = Math.max(...groundOffsets);

        // Cache ground offsets for soil handle drag calculations (stored as array in mm)
        this._soilGroundOffsets = groundOffsets.slice();

        const posts = this.getRunPosts(run);

        let maxPostAbove = 0;
        posts.forEach(p => {
          const above = p.postSize - embedDepthMm;
          if (above > maxPostAbove) maxPostAbove = above;
        });

        // ── Scaling: 90% width, 70% height ──
        // Compute max visible extent above groundY (accounting for plinths raising sheets)
        let maxAboveGndYMm = 0;
        run.panels.forEach((p, idx) => {
          const lowOffset = Math.max(groundOffsets[idx], groundOffsets[idx + 1]);
          const panelTopMm = panelTotalRetaining(p) + railHeightMm + p.height + railHeightMm;
          const above = panelTopMm - lowOffset;
          if (above > maxAboveGndYMm) maxAboveGndYMm = above;
        });
        const totalFenceWidthMm = panelCount * panelWidthMm + postCount * postWidthMm;
        const totalAboveMm = maxAboveGndYMm + 50; // small padding above fence top
        const totalBelowMm = maxGndOffset + embedDepthMm + 200;
        const totalVisualHeightMm = totalAboveMm + totalBelowMm + 150;

        const scaleX = (cw * 0.90) / totalFenceWidthMm;
        const scaleY = (ch * 0.70) / totalVisualHeightMm;
        const scale = Math.min(scaleX, scaleY);

        // Auto-fit on first render or when switching runs
        if (this._lastFittedRunId !== run.id) {
          this.profilePan = { x: 0, y: 0 };
          this.profileZoom = 1;
          this._lastFittedRunId = run.id;
        }

        // Pan/zoom transform
        ctx.save();
        ctx.translate(this.profilePan.x, this.profilePan.y);
        ctx.scale(this.profileZoom, this.profileZoom);

        const fencePixelW = totalFenceWidthMm * scale;
        const originX = (cw / this.profileZoom - fencePixelW) / 2;
        const groundY = (ch / this.profileZoom) * 0.55 + totalAboveMm * scale * 0.1;

        // Cache layout for soil handle drag math
        this._soilHandleLayout = { groundY, scale, groundOffsets, originX, postWidthMm, panelWidthMm };

        const railH = railHeightMm * scale;
        const footingWMm = 300;
        const footingHMm = 450;

        // ── Run label ──
        const labelFontSize = Math.max(11, Math.min(18, 14 * scale * 2.5));
        ctx.fillStyle = '#293C46';
        ctx.font = `700 ${labelFontSize}px Helvetica Neue, Helvetica, Arial, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.fillText(
          `${run.name}  ·  ${panelCount} panels  ·  ${run.length}m`,
          originX + fencePixelW / 2,
          groundY - maxAboveGndYMm * scale - 10
        );

        // ── Soil profile (retained earth behind plinths, viewed from LOW side) ──
        // Build the high-side ground profile as a path across the full run
        {
          let sx = originX;
          const earthBottomY = groundY + maxGndOffset * scale + embedDepthMm * scale + 50;

          ctx.save();
          ctx.beginPath();
          // Start at bottom-left
          ctx.moveTo(sx, earthBottomY);

          for (let ei = 0; ei <= panelCount; ei++) {
            const postGnd = groundY + groundOffsets[ei] * scale;
            const epanel = ei < panelCount ? run.panels[ei] : null;
            const epw = postWidthMm * scale;
            const epanelW = panelWidthMm * scale;

            // High-side ground at this post = low-side ground of adjacent panel - plinth stack
            // For a post, we use the highest adjacent panel's high-side level
            let highSideAtPost = postGnd; // default: no retaining = ground level
            if (ei > 0) {
              const lp = run.panels[ei - 1];
              const lpLowOff = Math.max(groundOffsets[ei - 1], groundOffsets[ei]);
              const lpLowGndY = groundY + lpLowOff * scale;
              const lpHighSide = lpLowGndY - panelTotalRetaining(lp) * scale;
              highSideAtPost = Math.min(highSideAtPost, lpHighSide);
            }
            if (ei < panelCount) {
              const rp = run.panels[ei];
              const rpLowOff = Math.max(groundOffsets[ei], groundOffsets[ei + 1]);
              const rpLowGndY = groundY + rpLowOff * scale;
              const rpHighSide = rpLowGndY - panelTotalRetaining(rp) * scale;
              highSideAtPost = Math.min(highSideAtPost, rpHighSide);
            }

            if (ei === 0) {
              // First post: line up from bottom to high-side level
              ctx.lineTo(sx, highSideAtPost);
            } else {
              // Step vertically at post junction then across
              ctx.lineTo(sx, highSideAtPost);
            }

            sx += epw; // past post

            if (epanel) {
              // Across the panel at its high-side level
              const pLowOff = Math.max(groundOffsets[ei], groundOffsets[ei + 1]);
              const pLowGndY = groundY + pLowOff * scale;
              const pHighSide = pLowGndY - panelTotalRetaining(epanel) * scale;
              ctx.lineTo(sx, pHighSide); // left edge of panel at high-side
              sx += epanelW;
              ctx.lineTo(sx, pHighSide); // right edge of panel at high-side
            }
          }

          // Close path down to bottom-right and back
          ctx.lineTo(sx, earthBottomY);
          ctx.closePath();

          // Earth fill gradient
          const earthTopY = groundY - maxGndOffset * scale - 200;
          const grdEarth = ctx.createLinearGradient(0, earthTopY, 0, earthBottomY);
          grdEarth.addColorStop(0, '#C4A882');
          grdEarth.addColorStop(1, '#8B7355');
          ctx.fillStyle = grdEarth;
          ctx.fill();
          ctx.restore();

          // Grass strip along the top edge of the earth profile (4px green line)
          ctx.save();
          ctx.lineWidth = 4;
          ctx.strokeStyle = '#5B8C3E';
          ctx.beginPath();
          let gx = originX;
          let firstPoint = true;
          for (let ei = 0; ei <= panelCount; ei++) {
            const postGnd = groundY + groundOffsets[ei] * scale;
            const epw = postWidthMm * scale;
            const epanelW = panelWidthMm * scale;
            const epanel = ei < panelCount ? run.panels[ei] : null;

            let highSideAtPost = postGnd;
            if (ei > 0) {
              const lp = run.panels[ei - 1];
              const lpLowOff = Math.max(groundOffsets[ei - 1], groundOffsets[ei]);
              const lpLowGndY = groundY + lpLowOff * scale;
              highSideAtPost = Math.min(highSideAtPost, lpLowGndY - panelTotalRetaining(lp) * scale);
            }
            if (ei < panelCount) {
              const rp = run.panels[ei];
              const rpLowOff = Math.max(groundOffsets[ei], groundOffsets[ei + 1]);
              const rpLowGndY = groundY + rpLowOff * scale;
              highSideAtPost = Math.min(highSideAtPost, rpLowGndY - panelTotalRetaining(rp) * scale);
            }

            if (firstPoint) {
              ctx.moveTo(gx, highSideAtPost);
              firstPoint = false;
            } else {
              ctx.lineTo(gx, highSideAtPost);
            }

            gx += epw;

            if (epanel) {
              const pLowOff = Math.max(groundOffsets[ei], groundOffsets[ei + 1]);
              const pLowGndY = groundY + pLowOff * scale;
              const pHighSide = pLowGndY - panelTotalRetaining(epanel) * scale;
              ctx.lineTo(gx, pHighSide);
              gx += epanelW;
              ctx.lineTo(gx, pHighSide);
            }
          }
          ctx.stroke();
          ctx.restore();
        }

        // ── Draw posts and panels ──
        let cursorX = originX;
        const pw = postWidthMm * scale;

        for (let i = 0; i <= panelCount; i++) {
          const panel = i < panelCount ? run.panels[i] : null;
          const gndOff = groundOffsets[i] * scale;
          const postGndY = groundY + gndOff;

          // ── POST — height clamped to adjacent panel tops ──
          const postInfo = posts[i];

          // Find post top Y from adjacent panels' cap rail tops
          let postTopY = postGndY; // default
          const leftPanel = i > 0 ? run.panels[i - 1] : null;
          const rightPanel = i < panelCount ? run.panels[i] : null;
          if (leftPanel) {
            const lpLowOff = Math.max(groundOffsets[i - 1], groundOffsets[i]);
            const lpLowGndY = groundY + lpLowOff * scale;
            const lpCapTopY = lpLowGndY - (panelTotalRetaining(leftPanel) + railHeightMm + leftPanel.height + railHeightMm) * scale;
            postTopY = Math.min(postTopY, lpCapTopY);
          }
          if (rightPanel) {
            const rpLowOff = Math.max(groundOffsets[i], groundOffsets[i + 1]);
            const rpLowGndY = groundY + rpLowOff * scale;
            const rpCapTopY = rpLowGndY - (panelTotalRetaining(rightPanel) + railHeightMm + rightPanel.height + railHeightMm) * scale;
            postTopY = Math.min(postTopY, rpCapTopY);
          }
          const postAboveH = postGndY - postTopY;

          // Patio tube RHS behind the post (wider backing, same height)
          if (postInfo.patio) {
            const patioW = patioWidthMm * scale;
            const patioX = cursorX - (patioW - pw) / 2;
            ctx.fillStyle = fenceHex;
            ctx.fillRect(patioX, postTopY, patioW, postAboveH);
            ctx.strokeStyle = darkenHex(fenceHex, 0.7);
            ctx.lineWidth = 0.5;
            ctx.strokeRect(patioX, postTopY, patioW, postAboveH);
          }

          // Post body — fence colour
          ctx.fillStyle = fenceHex;
          ctx.fillRect(cursorX, postTopY, pw, postAboveH);
          ctx.fillStyle = 'rgba(0,0,0,0.2)';
          ctx.fillRect(cursorX, postTopY, 1, postAboveH);
          ctx.fillRect(cursorX + pw - 1, postTopY, 1, postAboveH);
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.fillRect(cursorX + (pw - 1) / 2, postTopY, 1, postAboveH);
          ctx.strokeStyle = darkenHex(fenceHex, 0.7);
          ctx.lineWidth = 0.5;
          ctx.strokeRect(cursorX, postTopY, pw, postAboveH);

          // Underground: faded post extension + concrete footing
          const embedH = embedDepthMm * scale;
          const postCentreX = cursorX + pw / 2;
          ctx.save();
          ctx.globalAlpha = 0.5;
          ctx.fillStyle = fenceHex;
          ctx.fillRect(cursorX, postGndY, pw, embedH);
          ctx.strokeStyle = darkenHex(fenceHex, 0.7);
          ctx.lineWidth = 0.5;
          ctx.strokeRect(cursorX, postGndY, pw, embedH);
          ctx.restore();
          const footingW = footingWMm * scale;
          const footingH = footingHMm * scale;
          const footingX = postCentreX - footingW / 2;
          const footingY = postGndY + embedH - footingH;
          ctx.fillStyle = '#A0A0A0';
          ctx.fillRect(footingX, footingY, footingW, footingH);
          ctx.save();
          ctx.setLineDash([4, 3]);
          ctx.strokeStyle = '#808080';
          ctx.lineWidth = 1;
          ctx.strokeRect(footingX, footingY, footingW, footingH);
          ctx.restore();

          cursorX += pw;

          // ── PANEL (correct construction stacking: plinths → bottom rail → sheets → cap rail) ──
          if (panel) {
            const panelW = panelWidthMm * scale;
            const sheetH = panel.height * scale;
            const totalRet = panelTotalRetaining(panel);
            const plinths = totalRet / plinthHeightMm;
            const plinthStackH = totalRet * scale;
            const btmRailH = railH;
            const capRailH = railH;

            // Low-side ground (bottom of plinths)
            const lowSideOff = Math.max(groundOffsets[i], groundOffsets[i + 1]);
            const lowSideGndY = groundY + lowSideOff * scale;
            // High-side ground (top of plinths)
            const highSideGndY = lowSideGndY - plinthStackH;

            // Stacking from bottom to top:
            const plinthBottomY = lowSideGndY;
            const btmRailBottomY = highSideGndY;
            const btmRailTopY = btmRailBottomY - btmRailH;
            const sheetBottomY = btmRailTopY;
            const sheetTopY = sheetBottomY - sheetH;
            const capRailTopY = sheetTopY - capRailH;

            // ── Plinths (Colorbond steel plinth panels with horizontal ribs) ──
            if (plinths > 0) {
              const plinthH = plinthHeightMm * scale;
              for (let pi = 0; pi < plinths; pi++) {
                const py = plinthBottomY - (pi + 1) * plinthH; // stack upward from low-side ground
                ctx.fillStyle = fenceHex;
                ctx.fillRect(cursorX, py, panelW, plinthH);
                const ribCount = 5;
                const ribSpacing = plinthH / (ribCount + 1);
                ctx.fillStyle = 'rgba(0,0,0,0.15)';
                for (let ri = 1; ri <= ribCount; ri++) {
                  ctx.fillRect(cursorX, py + ri * ribSpacing, panelW, 1);
                }
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.fillRect(cursorX, py + plinthH - 1, panelW, 1);
                if (pi < plinths - 1) {
                  ctx.fillStyle = 'rgba(0,0,0,0.25)';
                  ctx.fillRect(cursorX, py, panelW, 1);
                }
              }
              ctx.strokeStyle = darkenHex(fenceHex, 0.7);
              ctx.lineWidth = 0.5;
              ctx.strokeRect(cursorX, highSideGndY, panelW, plinthStackH);
            }

            // ── Bottom rail (from image crop) on top of plinths ──
            if (this._panelTextureLoaded) {
              const sr = this.SRC_RAIL;
              ctx.drawImage(this._panelTextureImg, sr.sx, sr.sy, sr.sw, sr.sh,
                cursorX, btmRailTopY, panelW, btmRailH);
              ctx.save();
              ctx.globalCompositeOperation = 'multiply';
              ctx.fillStyle = fenceHex;
              ctx.fillRect(cursorX, btmRailTopY, panelW, btmRailH);
              ctx.globalCompositeOperation = 'source-over';
              ctx.restore();
            } else {
              ctx.fillStyle = fenceHex;
              ctx.fillRect(cursorX, btmRailTopY, panelW, btmRailH);
            }
            ctx.strokeStyle = darkenHex(fenceHex, 0.7);
            ctx.lineWidth = 0.5;
            ctx.strokeRect(cursorX, btmRailTopY, panelW, btmRailH);

            // ── Sheets (tiled from image crop) on top of bottom rail ──
            ctx.save();
            ctx.beginPath();
            ctx.rect(cursorX, sheetTopY, panelW, sheetH);
            ctx.clip();

            if (this._panelTextureLoaded) {
              const ss = this.SRC_SHEET;
              const sheetWidthMm = 762;
              const numSheets = Math.max(1, Math.floor(panelWidthMm / sheetWidthMm));
              const tileW = panelW / numSheets;
              for (let si = 0; si < numSheets; si++) {
                ctx.drawImage(this._panelTextureImg, ss.sx, ss.sy, ss.sw, ss.sh,
                  cursorX + si * tileW, sheetTopY, tileW, sheetH);
              }
              ctx.globalCompositeOperation = 'multiply';
              ctx.fillStyle = fenceHex;
              ctx.fillRect(cursorX, sheetTopY, panelW, sheetH);
              ctx.globalCompositeOperation = 'source-over';
            } else {
              ctx.fillStyle = fenceHex;
              ctx.fillRect(cursorX, sheetTopY, panelW, sheetH);
            }
            ctx.restore();

            ctx.strokeStyle = darkenHex(fenceHex, 0.7);
            ctx.lineWidth = 0.5;
            ctx.strokeRect(cursorX, sheetTopY, panelW, sheetH);

            // ── Per-panel capping rail (from image crop) on top of sheets ──
            if (this._panelTextureLoaded) {
              const sc = this.SRC_CAP;
              ctx.drawImage(this._panelTextureImg, sc.sx, sc.sy, sc.sw, sc.sh,
                cursorX, capRailTopY, panelW, capRailH);
              ctx.save();
              ctx.globalCompositeOperation = 'multiply';
              ctx.fillStyle = fenceHex;
              ctx.fillRect(cursorX, capRailTopY, panelW, capRailH);
              ctx.globalCompositeOperation = 'source-over';
              ctx.restore();
            } else {
              ctx.fillStyle = fenceHex;
              ctx.fillRect(cursorX, capRailTopY, panelW, capRailH);
            }
            ctx.strokeStyle = darkenHex(fenceHex, 0.7);
            ctx.lineWidth = 0.5;
            ctx.strokeRect(cursorX, capRailTopY, panelW, capRailH);

            // ── Panel number (circled) ──
            const circleCX = cursorX + panelW / 2;
            const circleCY = sheetTopY + sheetH / 2;
            const circleR = Math.max(9, Math.min(18, 14 * scale));
            ctx.fillStyle = 'rgba(255,255,255,0.88)';
            ctx.beginPath();
            ctx.arc(circleCX, circleCY, circleR, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#293C46';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.fillStyle = '#293C46';
            const numFontSize = Math.max(8, Math.min(14, 11 * scale));
            ctx.font = `700 ${numFontSize}px Helvetica Neue, Helvetica, Arial, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`P${i + 1}`, circleCX, circleCY);

            // ── Highlight panel during retaining handle drag ──
            if (this._soilHandleDrag && this._soilHandleDrag.active) {
              const dragIdx = this._soilHandleDrag.panelIdx;
              if (dragIdx === i) {
                ctx.save();
                ctx.fillStyle = 'rgba(241,90,41,0.10)';
                ctx.fillRect(cursorX, capRailTopY, panelW, lowSideGndY - capRailTopY);
                ctx.strokeStyle = 'rgba(241,90,41,0.30)';
                ctx.lineWidth = 1.5;
                ctx.strokeRect(cursorX, capRailTopY, panelW, lowSideGndY - capRailTopY);
                ctx.restore();
              }
            }

            cursorX += panelW;
          }
        }

        // ── Ground gradient band ──
        const groundBandTop = groundY;
        const groundBandH = (ch / this.profileZoom) - groundBandTop + 100;
        if (groundBandH > 0) {
          const grdGround = ctx.createLinearGradient(0, groundBandTop, 0, groundBandTop + groundBandH);
          grdGround.addColorStop(0, 'rgba(74, 222, 128, 0.15)');
          grdGround.addColorStop(0.12, 'rgba(74, 222, 128, 0.06)');
          grdGround.addColorStop(0.4, 'rgba(146,64,14,0.05)');
          grdGround.addColorStop(1, 'rgba(146,64,14,0.1)');
          ctx.fillStyle = grdGround;
          ctx.fillRect(originX - 30, groundBandTop, fencePixelW + 60, groundBandH);
        }

        // ── Slope line (variable point-based ground profile) ──
        {
          const slopePoints = (run.slope && run.slope.points) || [];
          const slopeHandleR = 12;
          const runLengthM = run.length || 0;
          const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

          // Map slope points to world coordinates
          this._slopePointPositions = [];
          const slopeWorldPoints = [];
          for (let si = 0; si < slopePoints.length; si++) {
            const pt = slopePoints[si];
            const frac = runLengthM > 0 ? pt.distanceM / runLengthM : 0;
            const wx = originX + frac * fencePixelW;
            const wy = groundY - pt.heightMm * scale;
            slopeWorldPoints.push({ x: wx, y: wy });
            this._slopePointPositions.push({ x: wx, y: wy, pointIdx: si });
          }

          if (slopeWorldPoints.length >= 2) {
            // Draw slope line (2px solid earth brown)
            ctx.save();
            ctx.strokeStyle = '#8B7355';
            ctx.lineWidth = 2 / this.profileZoom;
            ctx.beginPath();
            ctx.moveTo(slopeWorldPoints[0].x, slopeWorldPoints[0].y);
            for (let si = 1; si < slopeWorldPoints.length; si++) {
              ctx.lineTo(slopeWorldPoints[si].x, slopeWorldPoints[si].y);
            }
            ctx.stroke();

            // 4px green grass strip on top of slope line
            ctx.strokeStyle = '#5B8C3E';
            ctx.lineWidth = 4 / this.profileZoom;
            ctx.beginPath();
            ctx.moveTo(slopeWorldPoints[0].x, slopeWorldPoints[0].y);
            for (let si = 1; si < slopeWorldPoints.length; si++) {
              ctx.lineTo(slopeWorldPoints[si].x, slopeWorldPoints[si].y);
            }
            ctx.stroke();
            ctx.restore();
          }

          // Draw labelled circles at each slope point — advanced mode only
          const slopeIsAdvanced = run.slope && run.slope.mode === 'advanced';
          if (slopeIsAdvanced) {
            for (let si = 0; si < slopeWorldPoints.length; si++) {
              const sp = slopeWorldPoints[si];
              const isHovered = this._slopePointHover === si;
              const isDragged = this._slopePointDrag && this._slopePointDrag.active && this._slopePointDrag.pointIdx === si;
              const letter = si < letters.length ? letters[si] : '?';

              ctx.beginPath();
              ctx.arc(sp.x, sp.y, slopeHandleR / this.profileZoom, 0, Math.PI * 2);
              ctx.fillStyle = isDragged ? '#6B5335' : (isHovered ? '#A0895F' : '#8B7355');
              ctx.fill();
              ctx.strokeStyle = '#FFFFFF';
              ctx.lineWidth = 2 / this.profileZoom;
              ctx.stroke();

              const labelSize = Math.max(7, Math.min(11, 9 / this.profileZoom));
              ctx.fillStyle = '#FFFFFF';
              ctx.font = `700 ${labelSize}px Helvetica Neue, Helvetica, Arial, sans-serif`;
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(letter, sp.x, sp.y);

              if (isDragged) {
                ctx.save();
                ctx.setLineDash([6 / this.profileZoom, 4 / this.profileZoom]);
                ctx.strokeStyle = 'rgba(139,115,85,0.5)';
                ctx.lineWidth = 1 / this.profileZoom;
                ctx.beginPath();
                ctx.moveTo(originX - 20, sp.y);
                ctx.lineTo(originX + fencePixelW + 20, sp.y);
                ctx.stroke();
                ctx.restore();
              }
            }
          }
        }

        // ── Retaining draggable handles (per-panel, orange) ──
        {
          const isTouchDevice = 'ontouchstart' in window;
          const showHandles = isTouchDevice || this._soilHandleProximity || (this._soilHandleDrag && this._soilHandleDrag.active);
          const handleR = isTouchDevice ? 12 : 8;
          const epw = postWidthMm * scale;
          const epanelW = panelWidthMm * scale;

          // Calculate handle positions (world coords) at each panel centre
          this._soilHandlePositions = [];
          let hx = originX;

          for (let hi = 0; hi < panelCount; hi++) {
            const panel = run.panels[hi];
            const totalRet = panelTotalRetaining(panel);

            // Panel X start = after post hi
            const panelStartX = hx + epw;
            const panelCentreX = panelStartX + epanelW / 2;

            // Handle Y = bottom rail position (top of plinths / high-side ground)
            const lowSideOff = Math.max(groundOffsets[hi], groundOffsets[hi + 1]);
            const lowSideGndY = groundY + lowSideOff * scale;
            const highSideGndY = lowSideGndY - totalRet * scale;
            const handleY = highSideGndY;

            this._soilHandlePositions.push({ x: panelCentreX, y: handleY, panelIdx: hi });

            // Draw handle if visible
            if (showHandles) {
              const isHovered = this._soilHandleHover === hi;
              const isDragged = this._soilHandleDrag && this._soilHandleDrag.active && this._soilHandleDrag.panelIdx === hi;

              ctx.beginPath();
              ctx.arc(panelCentreX, handleY, handleR / this.profileZoom, 0, Math.PI * 2);
              ctx.fillStyle = isDragged ? '#C44520' : (isHovered ? '#F47A52' : '#F15A29');
              ctx.fill();
              ctx.strokeStyle = '#FFFFFF';
              ctx.lineWidth = 2 / this.profileZoom;
              ctx.stroke();

              // If dragging this handle, draw a horizontal guide line
              if (isDragged) {
                ctx.save();
                ctx.setLineDash([6 / this.profileZoom, 4 / this.profileZoom]);
                ctx.strokeStyle = 'rgba(241,90,41,0.4)';
                ctx.lineWidth = 1 / this.profileZoom;
                ctx.beginPath();
                ctx.moveTo(originX - 20, handleY);
                ctx.lineTo(originX + fencePixelW + 20, handleY);
                ctx.stroke();
                ctx.restore();
              }
            }

            // Advance cursor: past this post + this panel
            hx += epw + epanelW;
          }
        }

        ctx.restore();
      },

      // ── Job Settings ──
      _jobSettingsOpen: false,

      toggleJobSettings() {
        this._jobSettingsOpen = !this._jobSettingsOpen;
        const body = document.getElementById('jsBody');
        const arrow = document.getElementById('jsToggleArrow');
        if (body) body.classList.toggle('collapsed', !this._jobSettingsOpen);
        if (arrow) arrow.classList.toggle('open', this._jobSettingsOpen);
      },

      saveJobSettings() {
        if (!this.job) return;
        this.job.jobSettings = this._readJobSettings();
        this.save();
      },

      _readJobSettings() {
        return {
          access: (document.getElementById('jsAccess') || {}).value || 'easy',
          urgency: (document.getElementById('jsUrgency') || {}).value || 'standard',
          delivery: parseFloat((document.getElementById('jsDelivery') || {}).value) || 250,
          removeHardie: !!(document.getElementById('jsRemoveHardie') || {}).checked,
          removeHardieQty: parseInt((document.getElementById('jsRemoveHardieQty') || {}).value) || 0,
          removeTimber: !!(document.getElementById('jsRemoveTimber') || {}).checked,
          removeTimberQty: parseFloat((document.getElementById('jsRemoveTimberQty') || {}).value) || 0,
          removeAsbestos: !!(document.getElementById('jsRemoveAsbestos') || {}).checked,
          removeAsbestosQty: parseInt((document.getElementById('jsRemoveAsbestosQty') || {}).value) || 0,
          vegClear: !!(document.getElementById('jsVegClear') || {}).checked,
          pedGate: !!(document.getElementById('jsPedGate') || {}).checked,
          pedGateQty: parseInt((document.getElementById('jsPedGateQty') || {}).value) || 1,
          dblGate: !!(document.getElementById('jsDblGate') || {}).checked,
          dblGateQty: parseInt((document.getElementById('jsDblGateQty') || {}).value) || 1,
          groundFinish: (document.getElementById('jsGroundFinish') || {}).value || 'none',
          custom: [0,1,2].map(i => ({
            desc: (document.getElementById('jsCustomDesc' + i) || {}).value || '',
            qty: parseFloat((document.getElementById('jsCustomQty' + i) || {}).value) || 0,
            unit: (document.getElementById('jsCustomUnit' + i) || {}).value || '',
            price: parseFloat((document.getElementById('jsCustomPrice' + i) || {}).value) || 0
          })),
          notes: (document.getElementById('jsNotes') || {}).value || ''
        };
      },

      _restoreJobSettings() {
        const js = this.job && this.job.jobSettings;
        if (!js) return;
        const setVal = (id, v) => { const el = document.getElementById(id); if (el) el.value = v; };
        const setChk = (id, v) => { const el = document.getElementById(id); if (el) el.checked = !!v; };
        setVal('jsAccess', js.access || 'easy');
        setVal('jsUrgency', js.urgency || 'standard');
        setVal('jsDelivery', js.delivery || 250);
        setChk('jsRemoveHardie', js.removeHardie);
        setVal('jsRemoveHardieQty', js.removeHardieQty || 0);
        setChk('jsRemoveTimber', js.removeTimber);
        setVal('jsRemoveTimberQty', js.removeTimberQty || 0);
        setChk('jsRemoveAsbestos', js.removeAsbestos);
        setVal('jsRemoveAsbestosQty', js.removeAsbestosQty || 0);
        setChk('jsVegClear', js.vegClear);
        setChk('jsPedGate', js.pedGate);
        setVal('jsPedGateQty', js.pedGateQty || 1);
        setChk('jsDblGate', js.dblGate);
        setVal('jsDblGateQty', js.dblGateQty || 1);
        setVal('jsGroundFinish', js.groundFinish || 'none');
        (js.custom || []).forEach((c, i) => {
          setVal('jsCustomDesc' + i, c.desc || '');
          setVal('jsCustomQty' + i, c.qty || 0);
          setVal('jsCustomUnit' + i, c.unit || '');
          setVal('jsCustomPrice' + i, c.price || 0);
        });
        setVal('jsNotes', js.notes || '');
      },

      // ── Compliance checks ──
      _runComplianceChecks() {
        const errors = []; // STOP errors
        const warnings = [];
        this.job.runs.forEach(run => {
          run.panels.forEach((panel, idx) => {
            const slopePl = panel.slopePlinths || 0;
            const manualPl = panel.retaining / 150;
            const totalPl = slopePl + manualPl;
            if (totalPl > 4) {
              errors.push(`${run.name} P${idx+1}: ${totalPl} plinths exceeds maximum 4. Requires engineered retaining solution.`);
            }
            const totalRet = Math.min(4, totalPl) * 150;
            if (totalRet > 500) {
              warnings.push(`${run.name} P${idx+1}: Retaining ${totalRet}mm > 500mm requires Building Permit + Engineer Cert in WA.`);
            }
          });
        });
        return { errors, warnings };
      },

      // ── Collect all data for outputs ──
      _collectOutputData() {
        const job = this.job;
        const js = this._readJobSettings();
        const supplier = SUPPLIER_PROFILES[job.supplier] || SUPPLIER_PROFILES.RNR;
        const panelWidthMm = supplier.panelWidth;
        const panelWidthM = panelWidthMm / 1000;

        let totalMetres = 0;
        let totalPanels = 0;
        let totalPosts = 0;
        let totalPlinths = 0;
        let totalPatioTubes = 0;
        const postGroups = {}; // { "1800_2400": { sheetH, postH, count } }
        const runDetails = [];

        job.runs.forEach(run => {
          const panelCount = run.panels.length;
          const postCount = panelCount + 1;
          totalMetres += run.length || 0;
          totalPanels += panelCount;
          totalPosts += postCount;

          let runPlinths = 0;
          let panelsWithPatio = 0;
          const panelDetails = [];

          // For each panel, compute derived values
          run.panels.forEach((panel, idx) => {
            const slopePl = panel.slopePlinths || 0;
            const manualPl = panel.retaining / 150;
            const totalPl = Math.min(4, slopePl + manualPl);
            const totalRet = totalPl * 150;
            const plinths = totalPl;
            runPlinths += plinths;

            const lookup = lookupPost(panel.height, totalRet);
            const postH = lookup.post;
            const patio = plinths >= 3 && plinths <= 4;
            if (patio) panelsWithPatio++;

            // Group panels by sheet height + post height for material order
            const key = `${panel.height}_${postH}`;
            if (!postGroups[key]) postGroups[key] = { sheetH: panel.height, postH, count: 0 };
            postGroups[key].count++;

            panelDetails.push({
              num: idx + 1,
              height: panel.height,
              retaining: totalRet,
              plinths,
              totalH: panel.height + totalRet,
              postH,
              patio,
              stepMm: panel.stepMm || 0
            });
          });

          const patioTubes = panelsWithPatio > 0 ? panelsWithPatio + 1 : 0;
          totalPlinths += runPlinths;
          totalPatioTubes += patioTubes;

          // Check if run has any retaining at all
          const hasRetaining = run.panels.some(p => {
            const sp = p.slopePlinths || 0;
            const mp = p.retaining / 150;
            return (sp + mp) > 0;
          });

          runDetails.push({
            name: run.name,
            length: run.length || 0,
            panelCount,
            postCount,
            plinths: runPlinths,
            patioTubes,
            panelsWithPatio,
            hasRetaining,
            panels: panelDetails
          });
        });

        // Corner post sharing: subtract (runs - 1) for connected runs
        if (job.runs.length > 1) totalPosts -= (job.runs.length - 1);

        // Gate posts
        let gatePosts = 0;
        const gateDetails = [];
        (job.gates || []).forEach(g => {
          const gp = g.type === 'double' ? 4 : 2;
          gatePosts += gp;
          gateDetails.push({ type: g.type, width: g.width, posts: gp });
        });
        // Also count job-settings gates
        let jsPedGatePosts = 0, jsDblGatePosts = 0;
        if (js.pedGate && js.pedGateQty > 0) {
          jsPedGatePosts = js.pedGateQty * 2;
          gatePosts += jsPedGatePosts;
        }
        if (js.dblGate && js.dblGateQty > 0) {
          jsDblGatePosts = js.dblGateQty * 4;
          gatePosts += jsDblGatePosts;
        }

        // Concrete: (totalPosts + gatePosts) * 2 * 1.1, round up to even
        const allPosts = totalPosts + gatePosts;
        const rawBags = allPosts * 2 * 1.1;
        const concreteBags = Math.ceil(rawBags / 2) * 2;

        // Tek screw boxes: 1 per 4 panels, min 1
        const tekBoxes = totalPanels > 0 ? Math.max(1, Math.ceil(totalPanels / 4)) : 0;

        // ── Pricing ──
        const pricePerMetre = job.pricePerMetre || 115;

        // Fencing line item
        const fencingTotal = totalMetres * pricePerMetre;

        // Plinths: sell price using margin formula
        const plinthSell = COST_PRICES.plinth / (1 - MARGIN);
        const plinthsTotal = totalPlinths * plinthSell;

        // Patio tubes
        const patioSell = COST_PRICES.patioTube / (1 - MARGIN);
        const patioTotal = totalPatioTubes * patioSell;

        // Gates from job settings
        let gatesTotal = 0;
        const gateLineItems = [];
        if (js.pedGate && js.pedGateQty > 0) {
          const sell = COST_PRICES.gateKitPedestrian / (1 - MARGIN);
          const postSell = COST_PRICES.gatePost90x90 / (1 - MARGIN);
          const lineTotal = js.pedGateQty * (sell + 2 * postSell);
          gatesTotal += lineTotal;
          gateLineItems.push({ desc: 'Pedestrian gate (supply + install)', qty: js.pedGateQty, total: lineTotal });
        }
        if (js.dblGate && js.dblGateQty > 0) {
          const sell = COST_PRICES.gateKitDouble / (1 - MARGIN);
          const postSell = COST_PRICES.gatePost90x90 / (1 - MARGIN);
          const lineTotal = js.dblGateQty * (sell + 4 * postSell);
          gatesTotal += lineTotal;
          gateLineItems.push({ desc: 'Double swing gate (supply + install)', qty: js.dblGateQty, total: lineTotal });
        }
        // Also gates from the panel section
        (job.gates || []).forEach(g => {
          if (g.type === 'pedestrian') {
            const sell = COST_PRICES.gateKitPedestrian / (1 - MARGIN);
            const postSell = COST_PRICES.gatePost90x90 / (1 - MARGIN);
            gatesTotal += sell + 2 * postSell;
            gateLineItems.push({ desc: `Pedestrian gate ${g.width}mm`, qty: 1, total: sell + 2 * postSell });
          } else if (g.type === 'double') {
            const sell = COST_PRICES.gateKitDouble / (1 - MARGIN);
            const postSell = COST_PRICES.gatePost90x90 / (1 - MARGIN);
            gatesTotal += sell + 4 * postSell;
            gateLineItems.push({ desc: `Double swing gate ${g.width}mm`, qty: 1, total: sell + 4 * postSell });
          }
        });

        // Removal items
        let removalTotal = 0;
        const removalItems = [];
        if (js.removeHardie && js.removeHardieQty > 0) {
          const t = js.removeHardieQty * (COST_PRICES.removeHardieSheet / (1 - MARGIN));
          removalTotal += t;
          removalItems.push({ desc: 'Remove Hardie sheets', qty: js.removeHardieQty, unit: 'sheets', total: t });
        }
        if (js.removeTimber && js.removeTimberQty > 0) {
          const t = js.removeTimberQty * (COST_PRICES.removeTimberLap / (1 - MARGIN));
          removalTotal += t;
          removalItems.push({ desc: 'Remove timber lap fence', qty: js.removeTimberQty, unit: 'm', total: t });
        }
        if (js.removeAsbestos && js.removeAsbestosQty > 0) {
          const t = js.removeAsbestosQty * (COST_PRICES.removeAsbestosSheet / (1 - MARGIN));
          removalTotal += t;
          removalItems.push({ desc: 'Remove asbestos sheets (licenced)', qty: js.removeAsbestosQty, unit: 'sheets', total: t });
        }
        if (js.vegClear) {
          const t = COST_PRICES.vegClear / (1 - MARGIN);
          removalTotal += t;
          removalItems.push({ desc: 'Vegetation / site clear', qty: 1, unit: 'lot', total: t });
        }

        // Ground finish
        let groundFinishTotal = 0;
        let groundFinishDesc = '';
        if (js.groundFinish && js.groundFinish !== 'none') {
          const rates = { mulch: COST_PRICES.groundMulch, stones: COST_PRICES.groundStones, turf: COST_PRICES.groundTurf };
          const costPerM = rates[js.groundFinish] || 0;
          const sellPerM = costPerM / (1 - MARGIN);
          groundFinishTotal = totalMetres * sellPerM;
          groundFinishDesc = js.groundFinish.charAt(0).toUpperCase() + js.groundFinish.slice(1) + ' ground finish';
        }

        // Custom items
        let customTotal = 0;
        const customItems = [];
        (js.custom || []).forEach(c => {
          if (c.desc && c.qty > 0 && c.price > 0) {
            const t = c.qty * c.price;
            customTotal += t;
            customItems.push({ desc: c.desc, qty: c.qty, unit: c.unit, unitPrice: c.price, total: t });
          }
        });

        // Access surcharge (on labour only)
        const labourBase = totalMetres * COST_PRICES.labourPerMetre;
        const accessRate = ACCESS_SURCHARGE[js.access] || 0;
        const accessSurcharge = labourBase * accessRate;

        // Delivery
        const deliveryFee = js.delivery || 250;

        // Subtotal before urgency
        const subtotalBeforeUrgency = fencingTotal + plinthsTotal + patioTotal + gatesTotal + removalTotal + groundFinishTotal + customTotal + accessSurcharge + deliveryFee;

        // Urgency surcharge (on subtotal)
        const urgencyRate = URGENCY_SURCHARGE[js.urgency] || 0;
        const urgencySurcharge = subtotalBeforeUrgency * urgencyRate;

        const subtotal = subtotalBeforeUrgency + urgencySurcharge;
        const gst = subtotal * 0.10;
        const grandTotal = subtotal + gst;

        // ── Internal cost breakdown ──
        let internalCost = 0;
        // Panel costs
        Object.values(postGroups).forEach(g => {
          let unitCost = COST_PRICES.panelKit1800_2400; // default
          if (g.sheetH === 1200) unitCost = COST_PRICES.panelKit1200_2400;
          else if (g.sheetH === 1500) unitCost = COST_PRICES.panelKit1500_2400;
          else if (g.sheetH === 1800) {
            if (g.postH <= 2400) unitCost = COST_PRICES.panelKit1800_2400;
            else if (g.postH <= 2700) unitCost = COST_PRICES.panelKit1800_2700;
            else unitCost = COST_PRICES.panelKit1800_3000;
          } else if (g.sheetH === 2100) {
            if (g.postH <= 2700) unitCost = COST_PRICES.panelKit2100_2700;
            else unitCost = COST_PRICES.panelKit2100_3000;
          }
          internalCost += g.count * unitCost;
        });
        internalCost += totalPlinths * COST_PRICES.plinth;
        internalCost += totalPatioTubes * COST_PRICES.patioTube;
        internalCost += concreteBags * COST_PRICES.concrete;
        internalCost += tekBoxes * COST_PRICES.tekScrewBox;
        if (js.pedGate) internalCost += js.pedGateQty * (COST_PRICES.gateKitPedestrian + 2 * COST_PRICES.gatePost90x90);
        if (js.dblGate) internalCost += js.dblGateQty * (COST_PRICES.gateKitDouble + 4 * COST_PRICES.gatePost90x90);
        (job.gates || []).forEach(g => {
          if (g.type === 'pedestrian') internalCost += COST_PRICES.gateKitPedestrian + 2 * COST_PRICES.gatePost90x90;
          else if (g.type === 'double') internalCost += COST_PRICES.gateKitDouble + 4 * COST_PRICES.gatePost90x90;
        });
        const labourCost = labourBase;
        const internalLabour = labourCost * (1 + accessRate);
        const materialMargin = subtotal - gst - internalCost - internalLabour;

        return {
          job, js, supplier: job.supplier, profile: job.profile, colour: job.colour,
          panelWidthMm, panelWidthM, pricePerMetre,
          totalMetres, totalPanels, totalPosts, totalPlinths, totalPatioTubes,
          postGroups, runDetails, gatePosts, gateDetails, gateLineItems,
          concreteBags, tekBoxes, allPosts,
          fencingTotal, plinthsTotal, plinthSell, patioTotal, patioSell,
          gatesTotal, removalTotal, removalItems,
          groundFinishTotal, groundFinishDesc, customTotal, customItems,
          accessSurcharge, accessRate, deliveryFee,
          urgencySurcharge, urgencyRate,
          subtotal, gst, grandTotal,
          internalCost, internalLabour, materialMargin,
          jsPedGatePosts, jsDblGatePosts
        };
      },

      // ── Generate output HTML documents ──
      generateOutputs() {
        // Run compliance checks
        const { errors, warnings } = this._runComplianceChecks();

        if (errors.length > 0) {
          alert('STOP — Cannot generate outputs:\n\n' + errors.join('\n\n'));
          return;
        }

        if (warnings.length > 0) {
          if (!confirm('Warnings detected:\n\n' + warnings.join('\n\n') + '\n\nProceed anyway?')) return;
        }

        // Restore settings from DOM
        const data = this._collectOutputData();

        // Generate 3 HTML documents in new tabs
        this._openOutputTab('Client Quote', this._generateQuoteHTML(data));
        this._openOutputTab('Material Order', this._generateMaterialOrderHTML(data));
        this._openOutputTab('Work Order', this._generateWorkOrderHTML(data));
      },

      _openOutputTab(title, html) {
        const w = window.open('', '_blank');
        if (!w) { alert('Popup blocked — please allow popups for this site.'); return; }
        w.document.write(html);
        w.document.close();
        w.document.title = title;
      },

      _fmt(n) { return n.toLocaleString('en-AU', { minimumFractionDigits: 2, maximumFractionDigits: 2 }); },

      _outputCSS() {
        return `
          body { font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; color: #293C46; margin: 0; padding: 30px 40px; font-size: 13px; line-height: 1.5; }
          .header { text-align: center; margin-bottom: 24px; border-bottom: 2px solid #293C46; padding-bottom: 16px; }
          .header h1 { font-size: 20px; margin: 0 0 4px 0; color: #293C46; }
          .header .company { font-size: 14px; font-weight: 700; color: #F15A29; margin-bottom: 2px; }
          .header .details { font-size: 11px; color: #4C6A70; }
          .section { margin-bottom: 20px; }
          .section h2 { font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid #4C6A70; padding-bottom: 4px; margin-bottom: 8px; color: #293C46; }
          .info-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 4px 20px; margin-bottom: 12px; }
          .info-grid .label { font-weight: 700; font-size: 11px; text-transform: uppercase; color: #4C6A70; }
          .info-grid .value { font-size: 13px; }
          table { width: 100%; border-collapse: collapse; margin-bottom: 12px; font-size: 12px; }
          th { background: #F5F5F5; padding: 6px 8px; text-align: left; font-size: 11px; text-transform: uppercase; border-bottom: 2px solid #4C6A70; }
          td { padding: 5px 8px; border-bottom: 1px solid #e5e7eb; }
          .text-right { text-align: right; }
          .total-row td { font-weight: 700; border-top: 2px solid #293C46; }
          .grand-total td { font-size: 16px; color: #F15A29; }
          .disclaimer { font-size: 10px; color: #666; line-height: 1.4; margin-bottom: 6px; }
          .disclaimer-num { font-weight: 700; }
          .flag { background: #fffbeb; border: 1px solid #f59e0b; padding: 8px 12px; border-radius: 4px; margin-bottom: 8px; font-size: 12px; }
          .flag.stop { background: #fef2f2; border-color: #dc2626; }
          pre { background: #f8fafc; padding: 16px; border: 1px solid #e5e7eb; border-radius: 4px; white-space: pre-wrap; font-size: 12px; font-family: 'Courier New', monospace; }
          .checklist li { margin-bottom: 4px; }
          .patio-flag { color: #F15A29; font-weight: 700; }
          @media print { body { padding: 15px 20px; } .no-print { display: none; } }
          .print-btn { position: fixed; top: 10px; right: 10px; padding: 8px 16px; background: #F15A29; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-weight: 700; font-size: 13px; }
          .print-btn:hover { background: #d94e22; }
        `;
      },

      _generateQuoteHTML(d) {
        const date = d.job.date || new Date().toISOString().slice(0, 10);
        const validUntil = new Date(new Date(date).getTime() + 30 * 86400000).toISOString().slice(0, 10);

        // Auto-generate description
        let scopeDesc = `Supply and professional installation of ${d.totalMetres.toFixed(1)} lineal metres of COLORBOND\u00AE ${d.profile} fencing in ${d.colour}`;
        if (d.totalPlinths > 0) scopeDesc += `, including ${d.totalPlinths} retaining plinths`;
        if (d.totalPatioTubes > 0) scopeDesc += ` with patio tube bracing`;
        scopeDesc += '. All posts set in concrete. Site clean-up included.';
        if (d.removalItems.length > 0) scopeDesc += ' Removal and disposal of existing fencing included.';

        let lineItemsHtml = '';
        lineItemsHtml += `<tr><td>COLORBOND\u00AE ${d.profile} fencing — ${d.colour} (${d.totalMetres.toFixed(1)}m @ $${d.pricePerMetre}/m)</td><td class="text-right">$${this._fmt(d.fencingTotal)}</td></tr>`;
        if (d.totalPlinths > 0) lineItemsHtml += `<tr><td>Retaining plinths (${d.totalPlinths} × 150mm)</td><td class="text-right">$${this._fmt(d.plinthsTotal)}</td></tr>`;
        if (d.totalPatioTubes > 0) lineItemsHtml += `<tr><td>Patio tube bracing (${d.totalPatioTubes} tubes)</td><td class="text-right">$${this._fmt(d.patioTotal)}</td></tr>`;
        d.gateLineItems.forEach(g => { lineItemsHtml += `<tr><td>${g.desc}${g.qty > 1 ? ' × ' + g.qty : ''}</td><td class="text-right">$${this._fmt(g.total)}</td></tr>`; });
        d.removalItems.forEach(r => { lineItemsHtml += `<tr><td>${r.desc} (${r.qty} ${r.unit})</td><td class="text-right">$${this._fmt(r.total)}</td></tr>`; });
        if (d.groundFinishTotal > 0) lineItemsHtml += `<tr><td>${d.groundFinishDesc} (${d.totalMetres.toFixed(1)}m)</td><td class="text-right">$${this._fmt(d.groundFinishTotal)}</td></tr>`;
        d.customItems.forEach(c => { lineItemsHtml += `<tr><td>${c.desc} (${c.qty} ${c.unit} @ $${this._fmt(c.unitPrice)})</td><td class="text-right">$${this._fmt(c.total)}</td></tr>`; });
        if (d.accessSurcharge > 0) lineItemsHtml += `<tr><td>Access difficulty surcharge (${d.js.access})</td><td class="text-right">$${this._fmt(d.accessSurcharge)}</td></tr>`;
        lineItemsHtml += `<tr><td>Delivery</td><td class="text-right">$${this._fmt(d.deliveryFee)}</td></tr>`;
        if (d.urgencySurcharge > 0) lineItemsHtml += `<tr><td>Urgency surcharge (${d.js.urgency})</td><td class="text-right">$${this._fmt(d.urgencySurcharge)}</td></tr>`;

        const disclaimersHtml = DISCLAIMERS.map((d, i) => `<p class="disclaimer"><span class="disclaimer-num">${i+1}.</span> ${d}</p>`).join('');

        return `<!DOCTYPE html><html><head><meta charset="UTF-8"><style>${this._outputCSS()}</style></head><body>
          <button class="print-btn no-print" onclick="window.print()">Print / PDF</button>
          <div class="header">
            <div class="company">SECUREWORKS WA PTY LTD</div>
            <div class="details">ABN 64 689 223 416 | fencing@secureworkswa.com.au | +61 489 267 772</div>
            <h1>CLIENT QUOTE</h1>
          </div>
          <div class="section">
            <div class="info-grid">
              <div><span class="label">Client:</span> <span class="value">${d.job.client || '—'}</span></div>
              <div><span class="label">Job Ref:</span> <span class="value">${d.job.ref || '—'}</span></div>
              <div><span class="label">Address:</span> <span class="value">${d.job.address || '—'}</span></div>
              <div><span class="label">Date:</span> <span class="value">${date}</span></div>
              <div></div>
              <div><span class="label">Valid until:</span> <span class="value">${validUntil}</span></div>
            </div>
          </div>
          <div class="section">
            <h2>Scope of Works</h2>
            <p>${scopeDesc}</p>
          </div>
          <div class="section">
            <h2>Pricing</h2>
            <table>
              <thead><tr><th>Item</th><th class="text-right">Amount</th></tr></thead>
              <tbody>
                ${lineItemsHtml}
              </tbody>
              <tfoot>
                <tr class="total-row"><td>Subtotal (excl. GST)</td><td class="text-right">$${this._fmt(d.subtotal)}</td></tr>
                <tr><td>GST (10%)</td><td class="text-right">$${this._fmt(d.gst)}</td></tr>
                <tr class="total-row grand-total"><td>TOTAL (incl. GST)</td><td class="text-right">$${this._fmt(d.grandTotal)}</td></tr>
              </tfoot>
            </table>
          </div>
          <div class="section">
            <h2>Payment Terms</h2>
            <p>50% deposit required to confirm booking. Balance due on completion.</p>
          </div>
          <div class="section">
            <h2>Terms &amp; Conditions</h2>
            ${disclaimersHtml}
          </div>
          ${d.js.notes ? `<div class="section"><h2>Notes</h2><p>${d.js.notes.replace(/\n/g, '<br>')}</p></div>` : ''}
          <div style="text-align:center;margin-top:30px;font-size:11px;color:#4C6A70;">
            SecureWorks WA PTY LTD | ABN 64 689 223 416 | fencing@secureworkswa.com.au | +61 489 267 772
          </div>
        </body></html>`;
      },

      _generateMaterialOrderHTML(d) {
        const tomorrow = new Date(Date.now() + 86400000).toISOString().slice(0, 10);

        let panelLines = '';
        Object.values(d.postGroups).forEach(g => {
          panelLines += `${g.count} \u00D7 ${g.sheetH}H \u00D7 ${d.panelWidthMm}W panels W/ ${g.postH}H posts\n    Profile: ${d.profile}\n    Colour: ${d.colour}\n\n`;
        });

        let order = '';
        order += `SECUREWORKS WA PTY LTD\nMaterial Order\n\n`;
        order += `Job Ref: ${d.job.ref || '\u2014'}\n`;
        order += `Customer: ${d.job.client || '\u2014'}\n`;
        order += `Delivery Address: ${d.job.address || '\u2014'}\n`;
        order += `Site Contact: 0489 267 772\n`;
        order += `Delivery Date: ${tomorrow} | Time: 8-10am\n`;
        order += `Supplier: ${d.supplier}\n\n`;
        order += `${'─'.repeat(50)}\nORDER DETAILS:\n${'─'.repeat(50)}\n\n`;
        order += `PANELS & POSTS:\n${panelLines}`;
        if (d.totalPlinths > 0) order += `PLINTHS:\n${d.totalPlinths} \u00D7 150mm Plinths \u2014 ${d.colour}\n\n`;
        if (d.totalPatioTubes > 0) {
          const patioCalcParts = d.runDetails.filter(r => r.patioTubes > 0).map(r => `${r.name}: ${r.panelsWithPatio} panels + 1 = ${r.patioTubes}`);
          order += `PATIO TUBING:\n${d.totalPatioTubes} \u00D7 76x38 RHS Patio Tube @ 3000mm\n    (${patioCalcParts.join('; ')})\n\n`;
        }
        if (d.gatePosts > 0) {
          order += `GATE POSTS:\n${d.gatePosts} \u00D7 90x90mm SHS Gate Posts\n\n`;
          // Gate kits
          const allGates = [];
          if (d.js.pedGate && d.js.pedGateQty > 0) allGates.push(`${d.js.pedGateQty} \u00D7 Pedestrian gate kit | 900mm W | 1750mm H | ${d.colour}`);
          if (d.js.dblGate && d.js.dblGateQty > 0) allGates.push(`${d.js.dblGateQty} \u00D7 Double swing gate kit | ${d.colour}`);
          (d.job.gates || []).forEach(g => {
            if (g.type === 'pedestrian') allGates.push(`1 \u00D7 Pedestrian gate kit | ${g.width}mm W | ${d.colour}`);
            else if (g.type === 'double') allGates.push(`1 \u00D7 Double swing gate kit | ${g.width}mm W | ${d.colour}`);
          });
          if (allGates.length) order += `GATE KITS:\n${allGates.join('\n')}\n\n`;
        }
        order += `CONCRETE:\n${d.concreteBags} \u00D7 Bags Quickset Concrete\n\n`;
        order += `FIXINGS:\n${d.tekBoxes} \u00D7 Boxes Tek Screws\nFixings as required\n\n`;
        order += `${'─'.repeat(50)}\n\nPlease confirm. Thanks!\n\nSecureWorks WA\nfencing@secureworkswa.com.au | 0489 267 772`;

        return `<!DOCTYPE html><html><head><meta charset="UTF-8"><style>${this._outputCSS()}</style></head><body>
          <button class="print-btn no-print" onclick="window.print()">Print / PDF</button>
          <div class="header">
            <div class="company">SECUREWORKS WA PTY LTD</div>
            <div class="details">fencing@secureworkswa.com.au | 0489 267 772</div>
            <h1>MATERIAL ORDER</h1>
          </div>
          <div class="section">
            <pre>${order}</pre>
            <button class="no-print" style="margin-top:10px;padding:8px 16px;background:#293C46;color:#fff;border:none;border-radius:4px;cursor:pointer;font-weight:700;"
              onclick="navigator.clipboard.writeText(this.previousElementSibling.textContent).then(()=>this.textContent='Copied!').catch(()=>alert('Copy failed'))">
              Copy to Clipboard
            </button>
          </div>
        </body></html>`;
      },

      _generateWorkOrderHTML(d) {
        const date = d.job.date || new Date().toISOString().slice(0, 10);

        // Run breakdown
        let runsHtml = '';
        d.runDetails.forEach(r => {
          runsHtml += `<div class="section"><h2>${r.name} (${r.panelCount} panels, ${r.length}m)${r.patioTubes > 0 ? ` <span class="patio-flag">[${r.patioTubes} patio tubes]</span>` : ''}</h2>`;
          if (r.hasRetaining) {
            runsHtml += '<table><thead><tr><th>Panel</th><th>Fence</th><th>Ret.</th><th>Total</th><th>Post</th><th>Notes</th></tr></thead><tbody>';
            r.panels.forEach(p => {
              runsHtml += `<tr><td>P${p.num}</td><td>${p.height}mm</td><td>${p.retaining}mm</td><td>${p.totalH}mm</td><td>${p.postH}mm</td><td>${p.patio ? '<span class="patio-flag">PATIO TUBE</span>' : ''} ${p.stepMm !== 0 ? (p.stepMm < 0 ? '\u2193' + Math.abs(p.stepMm) + 'mm' : '\u2191' + p.stepMm + 'mm') : ''}</td></tr>`;
            });
            runsHtml += '</tbody></table>';
          } else {
            const postH = r.panels.length > 0 ? r.panels[0].postH : 2400;
            const sheetH = r.panels.length > 0 ? r.panels[0].height : 1800;
            runsHtml += `<p>P1\u2013P${r.panelCount}: ${sheetH}mm fence, 0mm retaining | Post height: ${postH}mm</p>`;
          }
          runsHtml += '</div>';
        });

        // Post breakdown by height
        const postByHeight = {};
        d.runDetails.forEach(r => {
          r.panels.forEach(p => {
            postByHeight[p.postH] = (postByHeight[p.postH] || 0) + 1;
          });
        });
        const postBreakdown = Object.entries(postByHeight).map(([h, c]) => `${c} @ ${h}mm`).join(', ');

        // Scope checklist
        let scopeChecklist = '<ul class="checklist">';
        scopeChecklist += '<li>Install COLORBOND\u00AE fencing per specification</li>';
        scopeChecklist += '<li>Set all posts in concrete (2 bags/post)</li>';
        if (d.totalPlinths > 0) scopeChecklist += `<li>Install ${d.totalPlinths} retaining plinths</li>`;
        if (d.totalPatioTubes > 0) scopeChecklist += `<li>Install ${d.totalPatioTubes} patio tubes at retained sections</li>`;
        d.removalItems.forEach(r => { scopeChecklist += `<li>${r.desc} (${r.qty} ${r.unit})</li>`; });
        d.gateLineItems.forEach(g => { scopeChecklist += `<li>${g.desc}</li>`; });
        if (d.groundFinishDesc) scopeChecklist += `<li>${d.groundFinishDesc}</li>`;
        scopeChecklist += '<li>Site clean-up and rubbish removal</li>';
        scopeChecklist += '</ul>';

        // Internal cost breakdown
        let costHtml = '<table><thead><tr><th>Item</th><th class="text-right">Cost</th></tr></thead><tbody>';
        costHtml += `<tr><td>Materials (panels, posts, plinths, concrete, fixings)</td><td class="text-right">$${this._fmt(d.internalCost)}</td></tr>`;
        costHtml += `<tr><td>Labour (${d.totalMetres.toFixed(1)}m @ $${COST_PRICES.labourPerMetre}/m${d.accessRate > 0 ? ' + ' + (d.accessRate * 100) + '% access' : ''})</td><td class="text-right">$${this._fmt(d.internalLabour)}</td></tr>`;
        costHtml += `<tr><td>Delivery</td><td class="text-right">$${this._fmt(d.deliveryFee)}</td></tr>`;
        costHtml += `<tr class="total-row"><td>Total cost</td><td class="text-right">$${this._fmt(d.internalCost + d.internalLabour + d.deliveryFee)}</td></tr>`;
        costHtml += `<tr><td>Quote total (excl. GST)</td><td class="text-right">$${this._fmt(d.subtotal)}</td></tr>`;
        costHtml += `<tr><td>Margin</td><td class="text-right">$${this._fmt(d.materialMargin)}</td></tr>`;
        costHtml += '</tbody></table>';

        return `<!DOCTYPE html><html><head><meta charset="UTF-8"><style>${this._outputCSS()}</style></head><body>
          <button class="print-btn no-print" onclick="window.print()">Print / PDF</button>
          <div class="header">
            <div class="company">SECUREWORKS WA PTY LTD</div>
            <h1>WORK ORDER \u2014 ${d.job.ref || '\u2014'}</h1>
          </div>
          <div class="section">
            <div class="info-grid">
              <div><span class="label">Client:</span> <span class="value">${d.job.client || '\u2014'}</span></div>
              <div><span class="label">Job Ref:</span> <span class="value">${d.job.ref || '\u2014'}</span></div>
              <div><span class="label">Address:</span> <span class="value">${d.job.address || '\u2014'}</span></div>
              <div><span class="label">Date:</span> <span class="value">${date}</span></div>
              <div><span class="label">Access:</span> <span class="value">${d.js.access}</span></div>
              <div><span class="label">Urgency:</span> <span class="value">${d.js.urgency}</span></div>
            </div>
          </div>
          <div class="section">
            <h2>Fence Specification</h2>
            <div class="info-grid">
              <div><span class="label">Supplier:</span> <span class="value">${d.supplier}</span></div>
              <div><span class="label">Profile:</span> <span class="value">${d.profile}</span></div>
              <div><span class="label">Colour:</span> <span class="value">${d.colour}</span></div>
              <div><span class="label">Panel width:</span> <span class="value">${d.panelWidthMm}mm</span></div>
            </div>
          </div>
          ${runsHtml}
          <div class="section">
            <h2>Gates</h2>
            ${d.gateLineItems.length > 0 || (d.job.gates && d.job.gates.length > 0) ? d.gateLineItems.map(g => `<p>${g.desc}${g.qty > 1 ? ' \u00D7 ' + g.qty : ''} \u2014 90x90mm SHS gate posts</p>`).join('') : '<p>None</p>'}
          </div>
          <div class="section">
            <h2>Summary</h2>
            <div class="info-grid">
              <div><span class="label">Total length:</span> <span class="value">${d.totalMetres.toFixed(1)}m</span></div>
              <div><span class="label">Panels:</span> <span class="value">${d.totalPanels}</span></div>
              <div><span class="label">Posts:</span> <span class="value">${d.totalPosts} (${postBreakdown})</span></div>
              <div><span class="label">Gate posts:</span> <span class="value">${d.gatePosts} \u00D7 90x90mm SHS</span></div>
              <div><span class="label">Plinths:</span> <span class="value">${d.totalPlinths}</span></div>
              <div><span class="label">Patio tubes:</span> <span class="value">${d.totalPatioTubes}</span></div>
              <div><span class="label">Concrete:</span> <span class="value">${d.concreteBags} bags</span></div>
              <div><span class="label">Tek screws:</span> <span class="value">${d.tekBoxes} boxes</span></div>
            </div>
          </div>
          <div class="section">
            <h2>Scope of Work</h2>
            ${scopeChecklist}
          </div>
          <div class="section">
            <h2>Safety &amp; Compliance</h2>
            <ul class="checklist">
              <li>Dial Before You Dig check completed: <strong>___</strong></li>
              <li>PPE: steel-cap boots, gloves, safety glasses, ear protection</li>
              <li>First aid kit on site</li>
              ${d.js.removeAsbestos ? '<li style="color:#dc2626;font-weight:700;">ASBESTOS: Licensed removal required. Do NOT break sheets.</li>' : ''}
              <li>No overhead power lines within 3m of work area confirmed: <strong>___</strong></li>
            </ul>
          </div>
          <div class="section">
            <h2>Completion Requirements</h2>
            <ul class="checklist">
              <li>QC photos of every post alignment and panel fit</li>
              <li>Client walkthrough and sign-off</li>
              <li>Tradify job completion sign-off</li>
              <li>All rubbish removed from site</li>
            </ul>
          </div>
          ${d.js.notes ? `<div class="section"><h2>Site Notes</h2><p>${d.js.notes.replace(/\n/g, '<br>')}</p></div>` : ''}
          <div class="section" style="border-top:2px solid #293C46;padding-top:16px;">
            <h2>Internal Cost Breakdown (CONFIDENTIAL)</h2>
            ${costHtml}
          </div>
        </body></html>`;
      },

      // ── LocalStorage ──
      save() {
        localStorage.setItem('fenceJob', JSON.stringify(this.job));
        const ind = document.getElementById('savedIndicator');
        if (ind) {
          ind.textContent = 'Saved';
          ind.style.opacity = '1';
          setTimeout(() => { ind.style.opacity = '0.7'; }, 1000);
        }
      },

      loadFromStorage() {
        const saved = localStorage.getItem('fenceJob');
        if (saved) {
          try {
            this.job = JSON.parse(saved);
            // Migration: ensure new fields exist
            if (!this.job.gates) this.job.gates = [];
            this.job.runs.forEach(run => {
              if (run.sheetHeight === undefined) run.sheetHeight = run.defaultHeight || 1800;
              if (run.extension === undefined || run.extension === null) run.extension = 'none';
              // Migrate to new slope.points system
              if (!run.slope || !run.slope.points) {
                const runLen = run.length || 0;
                if (run.slopeProfile && run.slopeProfile.some(v => v !== 0)) {
                  const fracs = [0, 0.25, 0.50, 0.75, 1.0];
                  const rawPts = fracs.map((f, i) => ({
                    distanceM: Math.round(f * runLen * 2) / 2,
                    heightMm: run.slopeProfile[i]
                  }));
                  const simplified = [rawPts[0]];
                  for (let j = 1; j < rawPts.length - 1; j++) {
                    const prev = simplified[simplified.length - 1];
                    const next = rawPts[rawPts.length - 1];
                    const span = next.distanceM - prev.distanceM;
                    if (span === 0) continue;
                    const t = (rawPts[j].distanceM - prev.distanceM) / span;
                    const interp = prev.heightMm + t * (next.heightMm - prev.heightMm);
                    if (Math.abs(rawPts[j].heightMm - interp) > 10) simplified.push(rawPts[j]);
                  }
                  simplified.push(rawPts[rawPts.length - 1]);
                  run.slope = { mode: 'advanced', points: simplified, simple: { direction: 'left-to-right', totalFallMm: 0, startsFrom: 'start' }, monotonic: null };
                } else if (run.slopePoints && run.slopePoints.length >= 2) {
                  run.slope = {
                    mode: 'advanced',
                    points: run.slopePoints.map(p => ({
                      distanceM: Math.round(p.x * runLen * 2) / 2,
                      heightMm: p.y || 0
                    })),
                    simple: { direction: 'left-to-right', totalFallMm: 0, startsFrom: 'start' },
                    monotonic: null
                  };
                } else {
                  run.slope = {
                    mode: 'simple',
                    points: [
                      { distanceM: 0, heightMm: 0 },
                      { distanceM: runLen, heightMm: 0 }
                    ],
                    simple: { direction: 'left-to-right', totalFallMm: 0, startsFrom: 'start' },
                    monotonic: null
                  };
                }
                delete run.slopeProfile;
                delete run.slopePoints;
              }
              // Ensure new slope fields exist on existing slope data
              if (!run.slope.mode) run.slope.mode = 'simple';
              if (!run.slope.simple) run.slope.simple = { direction: 'left-to-right', totalFallMm: 0, startsFrom: 'start' };
              if (run.slope.monotonic === undefined) run.slope.monotonic = null;
              run.panels.forEach(p => {
                if (p.step === undefined) p.step = p.ground || 'level';
                if (p.slopePlinths === undefined) p.slopePlinths = 0;
                if (p.stepMm === undefined) p.stepMm = 0;
                // Clamp any legacy 750mm retaining to 600mm max
                if (p.retaining > 600) p.retaining = 600;
              });
            });
            if (this.job.runs.length > 0 && !this.currentRunId) {
              this.currentRunId = this.job.runs[0].id;
            }
          } catch (e) {
            this.job = null;
          }
        }
      }
    };

    window.addEventListener('DOMContentLoaded', () => app.init());
  </script>
</body>
</html>
