<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fence Designer Pro ‚Äî SecureWorks WA</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 400;
      background: #f8fafc;
    }

    /* Section 0: Branding */
    .header {
      background: #293C46;
      color: #FFFFFF;
      padding: 12px 20px;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
    }

    .header-brand {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 700;
      font-size: 16px;
      margin-right: 8px;
      white-space: nowrap;
    }

    .header-group {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .header-group label {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 700;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      opacity: 0.85;
    }

    .header-group input,
    .header-group select {
      padding: 5px 8px;
      border: 1px solid #4C6A70;
      border-radius: 4px;
      font-size: 13px;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    }

    .header-group input {
      min-width: 100px;
    }

    .header-group select {
      min-width: 120px;
    }

    .header-actions {
      margin-left: auto;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .header-actions .saved-indicator {
      font-size: 12px;
      opacity: 0.7;
    }

    .btn-header {
      padding: 6px 14px;
      background: #F15A29;
      color: #FFFFFF;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 700;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    }

    .btn-header:hover {
      background: #d94e22;
    }

    /* Main Layout */
    .main {
      display: flex;
      height: calc(100vh - 72px);
    }

    .left-panel {
      width: 40%;
      min-width: 450px;
      background: #FFFFFF;
      overflow-y: auto;
      border-right: 1px solid #4C6A70;
    }

    .right-panel {
      width: 60%;
      background: #f8fafc;
      display: flex;
      flex-direction: column;
    }

    /* Run Tabs */
    .run-tabs {
      display: flex;
      background: #F5F5F5;
      border-bottom: 2px solid #4C6A70;
      padding: 8px 8px 0 8px;
      gap: 4px;
      flex-wrap: wrap;
    }

    .run-tab {
      padding: 8px 16px;
      background: #e5e7eb;
      border: 1px solid #4C6A70;
      border-bottom: none;
      border-radius: 4px 4px 0 0;
      cursor: pointer;
      font-size: 13px;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 400;
      color: #4C6A70;
    }

    .run-tab.active {
      background: #FFFFFF;
      font-weight: 700;
      color: #293C46;
      border-bottom: 2px solid #FFFFFF;
      margin-bottom: -2px;
      border-left-color: #F15A29;
      border-top: 2px solid #F15A29;
      border-right-color: #F15A29;
    }

    .run-tab:not(.active):hover {
      background: #d1d5db;
    }

    .add-run-btn {
      padding: 8px 16px;
      background: transparent;
      color: #F15A29;
      border: 2px dashed #F15A29;
      border-bottom: none;
      border-radius: 4px 4px 0 0;
      cursor: pointer;
      font-size: 13px;
      font-weight: 700;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    }

    .add-run-btn:hover {
      background: rgba(241, 90, 41, 0.08);
    }

    /* Run Content */
    .run-content {
      padding: 16px;
    }

    .run-settings {
      background: #F5F5F5;
      padding: 14px;
      border-radius: 4px;
      margin-bottom: 16px;
      border: 1px solid #4C6A70;
    }

    .run-settings h3 {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 700;
      font-size: 13px;
      margin-bottom: 10px;
      color: #293C46;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .run-settings-grid {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
    }

    .run-settings-actions {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .form-group {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .form-group label {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 700;
      font-size: 11px;
      color: #4C6A70;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .form-group input,
    .form-group select {
      padding: 5px 8px;
      border: 1px solid #4C6A70;
      border-radius: 4px;
      font-size: 13px;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    }

    .form-group input:focus,
    .form-group select:focus {
      outline: none;
      border-color: #F15A29;
      box-shadow: 0 0 0 2px rgba(241, 90, 41, 0.15);
    }

    .btn-orange {
      padding: 6px 14px;
      background: #F15A29;
      color: #FFFFFF;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 700;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    }

    .btn-orange:hover {
      background: #d94e22;
    }

    .btn-delete {
      padding: 6px 14px;
      background: transparent;
      color: #dc2626;
      border: none;
      cursor: pointer;
      font-size: 13px;
      font-weight: 700;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    }

    .btn-delete:hover {
      text-decoration: underline;
    }

    /* Quick Retaining Tool */
    .quick-retaining {
      background: #fef3c7;
      border: 1px solid #4C6A70;
      padding: 14px;
      border-radius: 4px;
      margin-bottom: 16px;
    }

    .quick-retaining h3 {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 700;
      font-size: 13px;
      margin-bottom: 10px;
      color: #293C46;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .quick-retaining-row {
      display: flex;
      gap: 10px;
      align-items: end;
    }

    /* Panel Table */
    .panel-table-section {
      margin-bottom: 16px;
    }

    .panel-table-section h3 {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 700;
      font-size: 13px;
      margin-bottom: 8px;
      color: #293C46;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .panel-table-wrap {
      max-height: 400px;
      overflow-y: auto;
      border: 1px solid #4C6A70;
      border-radius: 4px;
    }

    .panel-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }

    .panel-table thead {
      position: sticky;
      top: 0;
      z-index: 1;
    }

    .panel-table th {
      background: #F5F5F5;
      padding: 6px 6px;
      text-align: center;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 700;
      font-size: 11px;
      color: #293C46;
      border-bottom: 2px solid #4C6A70;
      text-transform: uppercase;
      letter-spacing: 0.3px;
      white-space: nowrap;
    }

    .panel-table td {
      padding: 4px 4px;
      border-bottom: 1px solid #e5e7eb;
      text-align: center;
      font-size: 12px;
    }

    .panel-table tbody tr:nth-child(even) {
      background: #F5F5F5;
    }

    .panel-table tbody tr:hover {
      background: #e0f2fe;
    }

    .panel-table select {
      padding: 2px 4px;
      border: 1px solid #4C6A70;
      border-radius: 3px;
      font-size: 12px;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      text-align: center;
    }

    .panel-table .col-pnum {
      width: 30px;
      font-weight: 700;
      color: #293C46;
    }

    .panel-table .col-ht {
      width: 55px;
    }

    .panel-table .col-ret {
      width: 65px;
    }

    .panel-table .col-pl {
      width: 45px;
      font-weight: 700;
      color: #4C6A70;
    }

    .panel-table .col-step {
      width: 35px;
      color: #4C6A70;
    }

    .panel-table .col-total {
      width: 50px;
      font-weight: 700;
    }

    .panel-table .col-post {
      width: 55px;
      font-weight: 700;
    }

    .panel-table .col-del {
      width: 20px;
    }

    .total-standard {
      color: #16a34a;
    }

    .total-elevated {
      color: #F15A29;
    }

    .post-patio {
      color: #F15A29;
    }

    .delete-panel-btn {
      background: none;
      border: none;
      color: #dc2626;
      cursor: pointer;
      font-size: 14px;
      font-weight: 700;
      padding: 2px 4px;
    }

    .delete-panel-btn:hover {
      background: #fee2e2;
      border-radius: 3px;
    }

    /* Gates */
    .gates-section {
      margin-bottom: 16px;
    }

    .gates-section h3 {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 700;
      font-size: 13px;
      margin-bottom: 8px;
      color: #293C46;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .gate-row {
      display: flex;
      gap: 8px;
      align-items: center;
      padding: 6px 0;
      border-bottom: 1px solid #e5e7eb;
    }

    .gate-row select,
    .gate-row input {
      padding: 4px 6px;
      border: 1px solid #4C6A70;
      border-radius: 3px;
      font-size: 12px;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    }

    /* Right Panel */
    .view-tabs {
      display: flex;
      background: #F5F5F5;
      border-bottom: 1px solid #4C6A70;
      padding: 0 16px;
    }

    .view-tab {
      padding: 10px 20px;
      background: transparent;
      border: none;
      cursor: pointer;
      font-size: 13px;
      font-weight: 700;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      color: #4C6A70;
      border-bottom: 3px solid transparent;
    }

    .view-tab.active {
      color: #F15A29;
      border-bottom-color: #F15A29;
    }

    .visualiser-placeholder {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      color: #4C6A70;
      font-weight: 400;
    }

    .profile-view-container {
      flex: 1;
      position: relative;
      overflow: hidden;
      cursor: grab;
      background: #f0f4f8;
    }

    .profile-view-container:active {
      cursor: grabbing;
    }

    .profile-view-container canvas {
      display: block;
    }

    .pv-tooltip {
      position: absolute;
      pointer-events: none;
      background: rgba(41,60,70,0.92);
      color: #fff;
      font-size: 11px;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 600;
      padding: 4px 8px;
      border-radius: 4px;
      white-space: nowrap;
      z-index: 10;
      transition: opacity 0.1s;
    }

    .soil-handle-tooltip {
      position: absolute;
      pointer-events: none;
      background: rgba(139,115,85,0.95);
      color: #fff;
      font-size: 11px;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 600;
      padding: 4px 10px;
      border-radius: 4px;
      white-space: nowrap;
      z-index: 12;
      display: none;
    }

    .pv-reset-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      z-index: 10;
      background: rgba(255,255,255,0.92);
      border: 1px solid #c0c8cc;
      border-radius: 4px;
      padding: 4px 10px;
      font-size: 11px;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 600;
      color: #293C46;
      cursor: pointer;
      transition: background 0.15s;
    }
    .pv-reset-btn:hover {
      background: rgba(255,255,255,1);
      border-color: #8899a4;
    }

    .panel-table tbody tr.panel-row-highlight {
      background: rgba(241,90,41,0.12) !important;
      outline: 2px solid #F15A29;
      outline-offset: -2px;
    }

    .stats-bar {
      background: #FFFFFF;
      border-top: 1px solid #4C6A70;
      padding: 14px 20px;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 12px;
      margin-bottom: 14px;
    }

    .stat-item {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .stat-item label {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 700;
      font-size: 10px;
      color: #4C6A70;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .stat-item .value {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-size: 16px;
      font-weight: 700;
      color: #293C46;
    }

    .stat-item .value.price-badge {
      color: #16a34a;
    }

    .generate-btn {
      width: 100%;
      padding: 12px;
      background: #F15A29;
      color: #FFFFFF;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 15px;
      font-weight: 700;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    }

    .generate-btn:hover {
      background: #d94e22;
    }

    /* Compliance Warnings */
    .compliance-warning {
      border: 1px solid #dc2626;
      border-left: 4px solid #dc2626;
      padding: 10px 14px;
      margin-bottom: 12px;
      border-radius: 4px;
      background: #fef2f2;
    }

    .compliance-warning.warn {
      border-color: #f59e0b;
      background: #fffbeb;
    }

    .compliance-warning h4 {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-weight: 700;
      font-size: 13px;
      margin-bottom: 4px;
    }

    .compliance-warning p {
      font-size: 12px;
    }

    /* Colour swatch in dropdown */
    .colour-option-swatch {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 2px;
      border: 1px solid #ccc;
      vertical-align: middle;
      margin-right: 6px;
    }

    /* No shadows heavier than spec */
    * {
      box-shadow: none;
    }
  </style>
</head>
<body>
  <!-- Header Bar -->
  <div class="header">
    <div class="header-brand">SW</div>
    <div class="header-group">
      <label>Job Ref</label>
      <input type="text" id="jobRef" placeholder="SW9248">
    </div>
    <div class="header-group">
      <label>Client</label>
      <input type="text" id="client" placeholder="Client name">
    </div>
    <div class="header-group">
      <label>Address</label>
      <input type="text" id="address" placeholder="Site address" style="min-width:160px;">
    </div>
    <div class="header-group">
      <label>Supplier</label>
      <select id="supplier">
        <option value="RNR">RNR</option>
        <option value="Metroll">Metroll</option>
        <option value="Lysaght">Lysaght</option>
        <option value="Stratco">Stratco</option>
      </select>
    </div>
    <div class="header-group">
      <label>Profile</label>
      <select id="profile"></select>
    </div>
    <div class="header-group">
      <label>Colour</label>
      <select id="colour"></select>
    </div>
    <div class="header-group">
      <label>$/Metre</label>
      <input type="number" id="pricePerMetre" value="115" step="0.01" min="0" style="min-width:70px;">
    </div>
    <div class="header-actions">
      <span class="saved-indicator" id="savedIndicator">Saved</span>
      <button class="btn-header" onclick="app.newJob()">New</button>
    </div>
  </div>

  <!-- Main Layout -->
  <div class="main">
    <!-- Left Panel -->
    <div class="left-panel">
      <div class="run-tabs" id="runTabs"></div>
      <div class="run-content" id="runContent"></div>
    </div>

    <!-- Right Panel -->
    <div class="right-panel">
      <div class="view-tabs">
        <button class="view-tab active" onclick="app.switchView('profile')">Profile View</button>
        <button class="view-tab" onclick="app.switchView('3d')">3D View</button>
      </div>
      <div class="profile-view-container" id="profileViewContainer">
        <canvas id="profileCanvas"></canvas>
        <div class="pv-tooltip" id="pvTooltip" style="display:none;"></div>
        <div class="soil-handle-tooltip" id="soilHandleTooltip"></div>
        <button class="pv-reset-btn" onclick="app.resetProfileView()">Reset View</button>
      </div>
      <div class="visualiser-placeholder" id="threeDPlaceholder" style="display:none;">
        3D View ‚Äî coming soon
      </div>

      <!-- Stats Bar -->
      <div class="stats-bar">
        <div class="stats-grid">
          <div class="stat-item">
            <label>Metres</label>
            <div class="value" id="statMetres">0.0m</div>
          </div>
          <div class="stat-item">
            <label>Panels</label>
            <div class="value" id="statPanels">0</div>
          </div>
          <div class="stat-item">
            <label>Posts</label>
            <div class="value" id="statPosts">0</div>
          </div>
          <div class="stat-item">
            <label>Plinths</label>
            <div class="value" id="statPlinths">0</div>
          </div>
          <div class="stat-item">
            <label>Est. Total</label>
            <div class="value price-badge" id="statCost">$0</div>
          </div>
        </div>
        <button class="generate-btn" onclick="app.generateOutputs()">Generate Outputs</button>
      </div>
    </div>
  </div>

  <script>
    // ‚îÄ‚îÄ Section 4B: Supplier profiles ‚îÄ‚îÄ
    const SUPPLIER_PROFILES = {
      RNR:    { profiles: ['Ridgeside', 'Sameside'], panelWidth: 2380 },
      Metroll:{ profiles: ['Trimclad', 'Harmony'],   panelWidth: 2365 },
      Lysaght:{ profiles: ['Neetascreen', 'Smartascreen'], panelWidth: 2360 },
      Stratco:{ profiles: ['Superdek', 'Good Neighbour'],  panelWidth: 2350 }
    };

    // ‚îÄ‚îÄ Section 9: Colorbond fencing colour palette ‚îÄ‚îÄ
    const COLOURS_STOCK = [
      { name: 'Surfmist',       hex: '#E4E2D5' },
      { name: 'Domain',         hex: '#E8DBAE' },
      { name: 'Evening Haze',   hex: '#C5C2AA' },
      { name: 'Paperbark',      hex: '#CABFA4' },
      { name: 'Dune',           hex: '#B1ADA3' },
      { name: 'Shale Grey',     hex: '#BDBFBA' },
      { name: 'Riversand',      hex: '#9D8D76' },
      { name: 'Bluegum',        hex: '#969799' },
      { name: 'Pale Eucalypt',  hex: '#7C846A' },
      { name: 'Wilderness',     hex: '#64715E' },
      { name: 'Basalt',         hex: '#6D6C6E' },
      { name: 'Woodland Grey',  hex: '#4B4C46' },
      { name: 'Ironstone',      hex: '#3E434C' },
      { name: 'Monument',       hex: '#323233' },
      { name: 'Wollemi',        hex: '#0A1C0D' }
    ];

    const COLOURS_SPECIAL = [
      { name: 'Deep Ocean',   hex: '#364152' },
      { name: 'Cottage Green',hex: '#304C3C' },
      { name: 'Night Sky',    hex: '#2E2E2F' },
      { name: 'Manor Red',    hex: '#5E1D0E' },
      { name: 'Jasper',       hex: '#6C6153' },
      { name: 'Windspray',    hex: '#888B8A' }
    ];

    // ‚îÄ‚îÄ Section 6.3: Post height lookup tables ‚îÄ‚îÄ
    // Key: sheetHeight, Value: array of { maxRetaining, postSize, patioTube }
    const POST_LOOKUP = {
      1200: [
        { ret: 0,   post: 2400, patio: false },
        { ret: 150, post: 2400, patio: false },
        { ret: 300, post: 2400, patio: false },
        { ret: 450, post: 2400, patio: false },
        { ret: 600, post: 2400, patio: false }
      ],
      1500: [
        { ret: 0,   post: 2400, patio: false },
        { ret: 150, post: 2400, patio: false },
        { ret: 300, post: 2400, patio: false },
        { ret: 450, post: 2700, patio: true },
        { ret: 600, post: 2700, patio: true }
      ],
      1800: [
        { ret: 0,   post: 2400, patio: false },
        { ret: 150, post: 2700, patio: false },
        { ret: 300, post: 2700, patio: false },
        { ret: 450, post: 3000, patio: true },
        { ret: 600, post: 3000, patio: true }
      ],
      2100: [
        { ret: 0,   post: 2700, patio: false },
        { ret: 150, post: 3000, patio: false },
        { ret: 300, post: 3000, patio: false },
        { ret: 450, post: 3000, patio: true },
        { ret: 600, post: 3000, patio: true }
      ]
    };

    const RETAINING_OPTIONS = [0, 150, 300, 450, 600];
    const SHEET_HEIGHTS = [1200, 1500, 1800, 2100];
    const RUN_NAME_CYCLE = ['Rear', 'LHS', 'RHS', 'Front'];

    // ‚îÄ‚îÄ Lookup helper ‚îÄ‚îÄ
    function lookupPost(sheetHeight, retaining) {
      const table = POST_LOOKUP[sheetHeight] || POST_LOOKUP[1800];
      const entry = table.find(e => e.ret === retaining);
      if (entry) return entry;
      // Fallback: use the formula from Section 6.3
      const totalFence = sheetHeight + retaining;
      const required = totalFence + 600;
      let postSize;
      if (required <= 2400) postSize = 2400;
      else if (required <= 2700) postSize = 2700;
      else if (required <= 3000) postSize = 3000;
      else postSize = 3000;
      const plinths = retaining / 150;
      return { ret: retaining, post: postSize, patio: plinths >= 3 && plinths <= 5 };
    }

    // ‚îÄ‚îÄ Application ‚îÄ‚îÄ
    const app = {
      job: null,
      currentRunId: null,

      init() {
        this.loadFromStorage();
        this.populateColourDropdown();
        this.bindHeaderInputs();

        if (!this.job) {
          this.job = {
            ref: '',
            client: '',
            address: '',
            supplier: 'RNR',
            profile: 'Ridgeside',
            colour: 'Shale Grey',
            pricePerMetre: 115,
            runs: [],
            gates: [],
            date: new Date().toISOString().slice(0, 10)
          };
          this.addRun();
        } else {
          this.syncHeaderFromJob();
          if (this.job.runs.length > 0 && !this.currentRunId) {
            this.currentRunId = this.job.runs[0].id;
          }
        }

        this.updateProfileDropdown();
        this._loadPanelTexture();
        this.render();

        // Resize handler for profile view canvas
        window.addEventListener('resize', () => this.renderProfileView());
      },

      // ‚îÄ‚îÄ Colour dropdown (Section 9.3) ‚îÄ‚îÄ
      populateColourDropdown() {
        const select = document.getElementById('colour');
        let html = '<optgroup label="‚îÄ‚îÄ Stock ‚îÄ‚îÄ">';
        COLOURS_STOCK.forEach(c => {
          html += `<option value="${c.name}" data-hex="${c.hex}">${c.name}</option>`;
        });
        html += '</optgroup><optgroup label="‚îÄ‚îÄ Special Order ‚îÄ‚îÄ">';
        COLOURS_SPECIAL.forEach(c => {
          html += `<option value="${c.name}" data-hex="${c.hex}">${c.name} (SO)</option>`;
        });
        html += '</optgroup>';
        select.innerHTML = html;
      },

      // ‚îÄ‚îÄ Profile dropdown (Section 4B) ‚îÄ‚îÄ
      updateProfileDropdown() {
        const select = document.getElementById('profile');
        const supplierData = SUPPLIER_PROFILES[this.job.supplier];
        select.innerHTML = supplierData.profiles.map(p =>
          `<option value="${p}" ${p === this.job.profile ? 'selected' : ''}>${p}</option>`
        ).join('');
        // If current profile is not valid for new supplier, reset to default
        if (!supplierData.profiles.includes(this.job.profile)) {
          this.job.profile = supplierData.profiles[0];
          select.value = this.job.profile;
        }
      },

      bindHeaderInputs() {
        document.getElementById('jobRef').addEventListener('input', (e) => {
          this.job.ref = e.target.value;
          this.save();
        });
        document.getElementById('client').addEventListener('input', (e) => {
          this.job.client = e.target.value;
          this.save();
        });
        document.getElementById('address').addEventListener('input', (e) => {
          this.job.address = e.target.value;
          this.save();
        });
        document.getElementById('supplier').addEventListener('change', (e) => {
          this.job.supplier = e.target.value;
          this.updateProfileDropdown();
          this.recalculateAll();
          this.save();
        });
        document.getElementById('profile').addEventListener('change', (e) => {
          this.job.profile = e.target.value;
          this.save();
        });
        document.getElementById('colour').addEventListener('change', (e) => {
          this.job.colour = e.target.value;
          this.renderProfileView();
          this.save();
        });
        document.getElementById('pricePerMetre').addEventListener('input', (e) => {
          this.job.pricePerMetre = parseFloat(e.target.value) || 0;
          this.updateStats();
          this.save();
        });
      },

      syncHeaderFromJob() {
        document.getElementById('jobRef').value = this.job.ref || '';
        document.getElementById('client').value = this.job.client || '';
        document.getElementById('address').value = this.job.address || '';
        document.getElementById('supplier').value = this.job.supplier || 'RNR';
        document.getElementById('colour').value = this.job.colour || 'Shale Grey';
        document.getElementById('pricePerMetre').value = this.job.pricePerMetre || 115;
      },

      // ‚îÄ‚îÄ Section 3.5: Panel width by supplier ‚îÄ‚îÄ
      getPanelWidthMm() {
        return SUPPLIER_PROFILES[this.job.supplier].panelWidth;
      },

      getPanelWidthM() {
        return this.getPanelWidthMm() / 1000;
      },

      // ‚îÄ‚îÄ Section 6.1: Auto-calculate panel count from run length ‚îÄ‚îÄ
      calcPanelCount(lengthM) {
        if (!lengthM || lengthM <= 0) return 0;
        const lengthMm = lengthM * 1000;
        return Math.ceil(lengthMm / this.getPanelWidthMm());
      },

      // ‚îÄ‚îÄ Section 6.3: Post height per-post (between two panels) ‚îÄ‚îÄ
      getPostHeight(leftPanel, rightPanel) {
        let leftTotal = 0, rightTotal = 0;
        let leftLookup = null, rightLookup = null;

        if (leftPanel) {
          leftTotal = leftPanel.height + leftPanel.retaining;
          leftLookup = lookupPost(leftPanel.height, leftPanel.retaining);
        }
        if (rightPanel) {
          rightTotal = rightPanel.height + rightPanel.retaining;
          rightLookup = lookupPost(rightPanel.height, rightPanel.retaining);
        }

        // Use whichever side demands the taller post
        let postSize = 2400;
        let patio = false;

        if (leftLookup && rightLookup) {
          postSize = Math.max(leftLookup.post, rightLookup.post);
          patio = leftLookup.patio || rightLookup.patio;
        } else if (leftLookup) {
          postSize = leftLookup.post;
          patio = leftLookup.patio;
        } else if (rightLookup) {
          postSize = rightLookup.post;
          patio = rightLookup.patio;
        }

        return { postSize, patio };
      },

      // ‚îÄ‚îÄ Sync panels to match calculated panel count ‚îÄ‚îÄ
      syncPanels(run) {
        const targetCount = this.calcPanelCount(run.length);
        if (targetCount === 0) {
          run.panels = [];
          return;
        }

        while (run.panels.length < targetCount) {
          run.panels.push({
            id: 'panel-' + Date.now() + '-' + Math.random().toString(36).slice(2, 6),
            height: run.sheetHeight,
            retaining: 0,
            step: 'level',
            slopePlinths: 0
          });
        }

        // If decreased, remove from end (but only excess)
        if (run.panels.length > targetCount) {
          run.panels = run.panels.slice(0, targetCount);
        }
      },

      // ‚îÄ‚îÄ Compute derived values per panel (not stored, used for display) ‚îÄ‚îÄ
      getPanelDerived(panel) {
        const slopePlinths = panel.slopePlinths || 0;
        const manualPlinths = panel.retaining / 150;
        const plinths = slopePlinths + manualPlinths;
        const totalRetaining = plinths * 150;
        const totalHeight = panel.height + totalRetaining;
        const lookup = lookupPost(panel.height, Math.min(600, totalRetaining));
        return {
          plinths,
          slopePlinths,
          manualPlinths,
          totalRetaining,
          totalHeight,
          postSize: lookup.post,
          patio: lookup.patio,
          needsPatioTube: plinths >= 3 && plinths <= 4
        };
      },

      // ‚îÄ‚îÄ Compute post array for a run (posts = panels + 1) ‚îÄ‚îÄ
      getRunPosts(run) {
        const posts = [];
        for (let i = 0; i <= run.panels.length; i++) {
          const leftPanel = i > 0 ? run.panels[i - 1] : null;
          const rightPanel = i < run.panels.length ? run.panels[i] : null;
          posts.push(this.getPostHeight(leftPanel, rightPanel));
        }
        return posts;
      },

      // ‚îÄ‚îÄ Slope interpolation: get ground height (mm) at fractional position along run ‚îÄ‚îÄ
      // slopePoints sorted by x (0..1), y in mm (0 = start height, negative = lower)
      interpolateSlope(slopePoints, fraction) {
        if (!slopePoints || slopePoints.length === 0) return 0;
        if (slopePoints.length === 1) return slopePoints[0].y;
        // Clamp fraction
        if (fraction <= slopePoints[0].x) return slopePoints[0].y;
        if (fraction >= slopePoints[slopePoints.length - 1].x) return slopePoints[slopePoints.length - 1].y;
        // Find the two points that bracket this fraction
        for (let i = 0; i < slopePoints.length - 1; i++) {
          const p0 = slopePoints[i];
          const p1 = slopePoints[i + 1];
          if (fraction >= p0.x && fraction <= p1.x) {
            const t = (fraction - p0.x) / (p1.x - p0.x);
            return p0.y + t * (p1.y - p0.y);
          }
        }
        return 0;
      },

      // ‚îÄ‚îÄ Calculate slope-derived steps and plinths for all panels in a run ‚îÄ‚îÄ
      // This sets panel.slopePlinths and panel.step based on the slope line.
      // Called whenever slopePoints change or panels are synced.
      calcSlopeForRun(run) {
        if (!run || !run.panels.length) return;
        const panelCount = run.panels.length;
        const slopePoints = run.slopePoints || [{ x: 0, y: 0 }, { x: 1, y: 0 }];
        const plinthH = 150;

        // Get the interpolated ground height at each post position (panelCount + 1 posts)
        // Post i is at fraction i / panelCount along the run
        const groundHeights = [];
        for (let i = 0; i <= panelCount; i++) {
          const frac = panelCount > 0 ? i / panelCount : 0;
          groundHeights.push(this.interpolateSlope(slopePoints, frac));
        }

        // Each panel spans from post i to post i+1.
        // The panel's "base level" snaps to the nearest plinthH step below the ground.
        // We work left-to-right. Panel 0's base = 0 (reference).
        // For each subsequent panel, the base steps down when the ground drops enough.

        // Panel base levels (in mm, relative to start ‚Äî 0 or negative)
        const baseLevels = new Array(panelCount).fill(0);
        baseLevels[0] = 0; // First panel is the reference

        for (let i = 1; i < panelCount; i++) {
          // Ground height at this panel's left post
          const groundAtPost = groundHeights[i];
          // How far has ground dropped from the previous panel's base?
          // Step down when ground drops a full plinthH below current base
          const prevBase = baseLevels[i - 1];
          const dropFromPrevBase = prevBase - groundAtPost; // positive = ground is lower
          if (dropFromPrevBase >= plinthH) {
            // Step down by however many full plinths fit
            const steps = Math.floor(dropFromPrevBase / plinthH);
            baseLevels[i] = prevBase - steps * plinthH;
          } else if (dropFromPrevBase <= -plinthH) {
            // Ground has risen ‚Äî step up
            const steps = Math.floor(-dropFromPrevBase / plinthH);
            baseLevels[i] = prevBase + steps * plinthH;
          } else {
            baseLevels[i] = prevBase;
          }
        }

        // Now calculate slopePlinths and step for each panel
        for (let i = 0; i < panelCount; i++) {
          const panel = run.panels[i];

          // Slope plinths = how far this panel's base is above the lowest ground
          // at either end of the panel, measured in plinth units
          const groundLeft = groundHeights[i];
          const groundRight = groundHeights[i + 1];
          const lowestGround = Math.min(groundLeft, groundRight);
          const gapMm = baseLevels[i] - lowestGround; // how far base is above ground
          const slopePlinths = Math.max(0, Math.min(4, Math.round(gapMm / plinthH)));
          panel.slopePlinths = slopePlinths;

          // Step direction: compare this panel's base to previous
          if (i === 0) {
            panel.step = 'level';
          } else {
            const diff = baseLevels[i] - baseLevels[i - 1];
            if (diff < 0) panel.step = 'down';
            else if (diff > 0) panel.step = 'up';
            else panel.step = 'level';
          }
        }
      },

      recalculateAll() {
        this.job.runs.forEach(run => this.syncPanels(run));
        this.render();
      },

      // ‚îÄ‚îÄ Runs ‚îÄ‚îÄ
      addRun() {
        const idx = this.job.runs.length;
        const name = idx < RUN_NAME_CYCLE.length ? RUN_NAME_CYCLE[idx] : 'Custom';
        const run = {
          id: 'run-' + Date.now(),
          name: name,
          length: 0,
          sheetHeight: 1800,
          extension: 'none',
          panels: [],
          slopePoints: [{ x: 0, y: 0 }, { x: 1, y: 0 }]
        };
        this.job.runs.push(run);
        this.currentRunId = run.id;
        this.save();
        this.render();
      },

      deleteRun(runId) {
        if (this.job.runs.length <= 1) {
          alert('Must have at least one run.');
          return;
        }
        if (!confirm('Delete this run?')) return;
        this.job.runs = this.job.runs.filter(r => r.id !== runId);
        if (this.currentRunId === runId) {
          this.currentRunId = this.job.runs[0].id;
        }
        this.save();
        this.render();
      },

      switchRun(runId) {
        this.currentRunId = runId;
        this.render();
      },

      updateRunSettings(runId, field, value) {
        const run = this.job.runs.find(r => r.id === runId);
        if (!run) return;

        if (field === 'name') {
          run.name = value;
        } else if (field === 'length') {
          run.length = parseFloat(value) || 0;
          this.syncPanels(run);
        } else if (field === 'sheetHeight') {
          run.sheetHeight = parseInt(value);
        } else if (field === 'extension') {
          run.extension = value;
        }

        this.save();
        this.render();
      },

      applyHeightToAll(runId) {
        const run = this.job.runs.find(r => r.id === runId);
        if (!run) return;
        run.panels.forEach(p => { p.height = run.sheetHeight; });
        this.save();
        this.render();
      },

      updatePanel(runId, panelIdx, field, value) {
        const run = this.job.runs.find(r => r.id === runId);
        if (!run || !run.panels[panelIdx]) return;

        const panel = run.panels[panelIdx];
        if (field === 'height') {
          panel.height = parseInt(value);
        } else if (field === 'retaining') {
          panel.retaining = parseInt(value);
        } else if (field === 'step') {
          panel.step = value;
        }

        this.save();
        this.render();
      },

      deletePanel(runId, panelIdx) {
        const run = this.job.runs.find(r => r.id === runId);
        if (!run || run.panels.length <= 1) return;
        run.panels.splice(panelIdx, 1);
        this.save();
        this.render();
      },

      applyQuickRetaining(runId) {
        const run = this.job.runs.find(r => r.id === runId);
        if (!run) return;

        const startPanel = parseInt(document.getElementById(`qr-start-${runId}`).value);
        const endPanel = parseInt(document.getElementById(`qr-end-${runId}`).value);
        const retaining = parseInt(document.getElementById(`qr-retaining-${runId}`).value);

        if (startPanel < 1 || endPanel > run.panels.length || startPanel > endPanel) {
          alert('Invalid panel range.');
          return;
        }

        for (let i = startPanel - 1; i < endPanel; i++) {
          run.panels[i].retaining = retaining;
        }

        this.save();
        this.render();
      },

      // ‚îÄ‚îÄ Gates ‚îÄ‚îÄ
      addGate() {
        if (!this.job.runs.length) return;
        this.job.gates.push({
          id: 'gate-' + Date.now(),
          type: 'pedestrian',
          width: 900,
          runIndex: 0,
          afterPanel: 1
        });
        this.save();
        this.render();
      },

      updateGate(gateId, field, value) {
        const gate = this.job.gates.find(g => g.id === gateId);
        if (!gate) return;
        if (field === 'type') gate.type = value;
        else if (field === 'width') gate.width = parseInt(value) || 900;
        else if (field === 'runIndex') gate.runIndex = parseInt(value);
        else if (field === 'afterPanel') gate.afterPanel = parseInt(value);
        this.save();
        this.render();
      },

      deleteGate(gateId) {
        this.job.gates = this.job.gates.filter(g => g.id !== gateId);
        this.save();
        this.render();
      },

      // ‚îÄ‚îÄ Section 11: Compliance warnings ‚îÄ‚îÄ
      getComplianceWarnings() {
        const warnings = [];
        this.job.runs.forEach(run => {
          run.panels.forEach((panel, idx) => {
            const totalRetaining = panel.retaining + (panel.slopePlinths || 0) * 150;
            const totalPlinths = totalRetaining / 150;
            if (totalPlinths >= 4) {
              warnings.push({
                type: 'warn',
                msg: `${run.name} P${idx + 1}: Panel at maximum plinth capacity (${totalRetaining}mm). Additional retaining requires engineered solution.`
              });
            }
            if (totalRetaining > 500) {
              warnings.push({
                type: 'warn',
                msg: `${run.name} P${idx + 1}: Retaining >${500}mm requires Building Permit + Engineer Cert in WA.`
              });
            }
          });
        });
        return warnings;
      },

      // ‚îÄ‚îÄ Stats ‚îÄ‚îÄ
      updateStats() {
        let totalPanels = 0;
        let totalPosts = 0;
        let totalMetres = 0;
        let totalPlinths = 0;
        let plinthPanelCount = 0;
        const panelWidthM = this.getPanelWidthM();
        const panelWidthMm = this.getPanelWidthMm();

        this.job.runs.forEach(run => {
          const panelCount = run.panels.length;
          totalPanels += panelCount;
          totalPosts += panelCount + 1;
          totalMetres += run.length || 0;
          run.panels.forEach(p => {
            const pl = (p.slopePlinths || 0) + p.retaining / 150;
            totalPlinths += pl;
            if (pl > 0) plinthPanelCount++;
          });
        });

        // Corner post sharing: if >1 run, subtract shared corners
        // Simple approximation: subtract (runs - 1) for connected runs
        // TODO: proper corner handling needs run-connection data

        const estimate = totalMetres * this.job.pricePerMetre * 1.1;

        document.getElementById('statMetres').textContent =
          totalMetres > 0 ? `${totalMetres.toFixed(1)}m / ${totalPanels} √ó ${panelWidthMm}mm` : '0.0m';
        document.getElementById('statPanels').textContent = totalPanels;
        document.getElementById('statPosts').textContent = totalPosts;
        document.getElementById('statPlinths').textContent =
          totalPlinths > 0 ? `${totalPlinths} (across ${plinthPanelCount} panels)` : '0';
        document.getElementById('statCost').textContent =
          estimate > 0 ? `$${Math.round(estimate).toLocaleString()} EST.` : '$0';
      },

      // ‚îÄ‚îÄ New Job ‚îÄ‚îÄ
      newJob() {
        if (!confirm('Start a new job? This will clear all current data.')) return;
        localStorage.removeItem('fenceJob');
        this.job = null;
        this.currentRunId = null;
        this.init();
      },

      // ‚îÄ‚îÄ Render ‚îÄ‚îÄ
      render() {
        // Recalc slope-derived steps + plinths for all runs before rendering
        this.job.runs.forEach(run => this.calcSlopeForRun(run));
        this.renderRunTabs();
        this.renderRunContent();
        this.updateStats();
        this.renderProfileView();
      },

      renderRunTabs() {
        const tabsHtml = this.job.runs.map(run => {
          const panelCount = run.panels.length;
          return `<div class="run-tab ${run.id === this.currentRunId ? 'active' : ''}"
                       onclick="app.switchRun('${run.id}')">
                    ${run.name}${panelCount > 0 ? ` (${panelCount})` : ''}
                  </div>`;
        }).join('');

        document.getElementById('runTabs').innerHTML = `
          ${tabsHtml}
          <button class="add-run-btn" onclick="app.addRun()">+ Add Run</button>
        `;
      },

      renderRunContent() {
        const run = this.job.runs.find(r => r.id === this.currentRunId);
        if (!run) {
          document.getElementById('runContent').innerHTML =
            '<p style="padding: 20px; color: #4C6A70;">No run selected. Click "+ Add Run" to begin.</p>';
          return;
        }

        // Warnings
        const warnings = this.getComplianceWarnings();
        let warningsHtml = '';
        warnings.forEach(w => {
          const cls = w.type === 'stop' ? '' : 'warn';
          warningsHtml += `<div class="compliance-warning ${cls}">
            <h4>${w.type === 'stop' ? 'üî¥ STOP' : '‚ö†Ô∏è Warning'}</h4>
            <p>${w.msg}</p>
          </div>`;
        });

        // Compute posts for this run
        const posts = this.getRunPosts(run);

        // Panel table rows
        const panelRows = run.panels.map((panel, idx) => {
          const derived = this.getPanelDerived(panel);
          // Post for this panel = the post to the RIGHT of the panel (post index idx+1)
          // But per spec, "Post" column shows the calculated post height.
          // Post at position idx sits between panel idx-1 and panel idx.
          // We'll show the max post relevant to this panel (max of left and right post).
          const leftPost = posts[idx];
          const rightPost = posts[idx + 1];
          const maxPost = Math.max(leftPost.postSize, rightPost.postSize);
          const anyPatio = leftPost.patio || rightPost.patio;

          const totalClass = derived.totalHeight > 1800 ? 'total-elevated' : 'total-standard';
          const postDisplay = anyPatio
            ? `<span class="post-patio">${maxPost}‚Ä†</span>`
            : `${maxPost}`;

          // Plinths display: append ‚Ä† when plinths >= 3 (patio tube required)
          const plinthsDisplay = derived.plinths >= 3 ? `${derived.plinths}‚Ä†` : `${derived.plinths}`;

          // Step is user input stored on the panel, not auto-calculated
          const stepValue = panel.step || 'level';

          return `<tr data-panel-idx="${idx}" onclick="app.selectPanel(${idx})" style="cursor:pointer;" class="${this.highlightedPanelIdx === idx ? 'panel-row-highlight' : ''}">
            <td class="col-pnum">P${idx + 1}</td>
            <td class="col-ht">
              <select onchange="app.updatePanel('${run.id}', ${idx}, 'height', this.value)">
                ${SHEET_HEIGHTS.map(h =>
                  `<option value="${h}" ${panel.height === h ? 'selected' : ''}>${h / 100}</option>`
                ).join('')}
              </select>
            </td>
            <td class="col-ret">
              <select onchange="app.updatePanel('${run.id}', ${idx}, 'retaining', this.value)">
                ${RETAINING_OPTIONS.map(r =>
                  `<option value="${r}" ${panel.retaining === r ? 'selected' : ''}>${r}</option>`
                ).join('')}
              </select>
            </td>
            <td class="col-pl">${plinthsDisplay}</td>
            <td class="col-step">
              <select onchange="app.updatePanel('${run.id}', ${idx}, 'step', this.value)">
                <option value="level" ${stepValue === 'level' ? 'selected' : ''}>‚Äî</option>
                <option value="up" ${stepValue === 'up' ? 'selected' : ''}>‚Üë</option>
                <option value="down" ${stepValue === 'down' ? 'selected' : ''}>‚Üì</option>
              </select>
            </td>
            <td class="col-total ${totalClass}">${derived.totalHeight}</td>
            <td class="col-post">${postDisplay}</td>
            <td class="col-del"><button class="delete-panel-btn" onclick="app.deletePanel('${run.id}', ${idx})" title="Delete panel">&times;</button></td>
          </tr>`;
        }).join('');

        // Extension dropdown value mapping
        const extOptions = [
          { value: 'none', label: 'None' },
          { value: 'slat', label: 'Slat' },
          { value: 'solid_fill', label: 'Solid Fill' },
          { value: 'lattice', label: 'Lattice' }
        ];

        // Gates section
        const gatesHtml = (this.job.gates || []).map(gate => `
          <div class="gate-row">
            <select onchange="app.updateGate('${gate.id}', 'type', this.value)">
              <option value="pedestrian" ${gate.type === 'pedestrian' ? 'selected' : ''}>Pedestrian</option>
              <option value="double" ${gate.type === 'double' ? 'selected' : ''}>Double</option>
              <option value="sliding" ${gate.type === 'sliding' ? 'selected' : ''}>Sliding</option>
            </select>
            <input type="number" value="${gate.width}" min="600" step="100" style="width:70px;"
                   onchange="app.updateGate('${gate.id}', 'width', this.value)" placeholder="mm">
            <select onchange="app.updateGate('${gate.id}', 'runIndex', this.value)">
              ${this.job.runs.map((r, ri) =>
                `<option value="${ri}" ${gate.runIndex === ri ? 'selected' : ''}>${r.name}</option>`
              ).join('')}
            </select>
            <label style="font-size:11px;">After P</label>
            <input type="number" value="${gate.afterPanel}" min="1" max="${run.panels.length}" style="width:50px;"
                   onchange="app.updateGate('${gate.id}', 'afterPanel', this.value)">
            <button class="delete-panel-btn" onclick="app.deleteGate('${gate.id}')" title="Delete gate">&times;</button>
          </div>
        `).join('');

        document.getElementById('runContent').innerHTML = `
          ${warningsHtml}

          <div class="run-settings">
            <h3>Run Settings</h3>
            <div class="run-settings-grid">
              <div class="form-group">
                <label>Name</label>
                <input type="text" value="${run.name}"
                       onchange="app.updateRunSettings('${run.id}', 'name', this.value)">
              </div>
              <div class="form-group">
                <label>Length (m)</label>
                <input type="number" value="${run.length || ''}" min="0" step="0.5" placeholder="0.0"
                       onchange="app.updateRunSettings('${run.id}', 'length', this.value)">
              </div>
              <div class="form-group">
                <label>Sheet Height</label>
                <select onchange="app.updateRunSettings('${run.id}', 'sheetHeight', this.value)">
                  ${SHEET_HEIGHTS.map(h =>
                    `<option value="${h}" ${run.sheetHeight === h ? 'selected' : ''}>${h}mm</option>`
                  ).join('')}
                </select>
              </div>
              <div class="form-group">
                <label>Extension</label>
                <select onchange="app.updateRunSettings('${run.id}', 'extension', this.value)">
                  ${extOptions.map(o =>
                    `<option value="${o.value}" ${run.extension === o.value ? 'selected' : ''}>${o.label}</option>`
                  ).join('')}
                </select>
              </div>
            </div>
            <div class="run-settings-actions">
              <button class="btn-orange" onclick="app.applyHeightToAll('${run.id}')">Apply Height to All</button>
              <button class="btn-delete" onclick="app.deleteRun('${run.id}')">Delete Run</button>
            </div>
          </div>

          <div class="quick-retaining">
            <h3>Quick Retaining Tool</h3>
            <div class="quick-retaining-row">
              <div class="form-group">
                <label>From Panel</label>
                <input type="number" id="qr-start-${run.id}" min="1" max="${run.panels.length}" value="1" style="width:60px;">
              </div>
              <div class="form-group">
                <label>To Panel</label>
                <input type="number" id="qr-end-${run.id}" min="1" max="${run.panels.length}" value="${run.panels.length}" style="width:60px;">
              </div>
              <div class="form-group">
                <label>Retaining (mm)</label>
                <select id="qr-retaining-${run.id}">
                  ${RETAINING_OPTIONS.map(r =>
                    `<option value="${r}">${r}</option>`
                  ).join('')}
                </select>
              </div>
              <button class="btn-orange" onclick="app.applyQuickRetaining('${run.id}')">Apply</button>
            </div>
          </div>

          <div class="panel-table-section">
            <h3>Panel Table</h3>
            <div class="panel-table-wrap">
              <table class="panel-table">
                <thead>
                  <tr>
                    <th>P#</th>
                    <th>Sheet Ht</th>
                    <th>Ret (mm)</th>
                    <th>Plinths</th>
                    <th>Step</th>
                    <th>Total</th>
                    <th>Post</th>
                    <th>&times;</th>
                  </tr>
                </thead>
                <tbody>
                  ${panelRows}
                </tbody>
              </table>
            </div>
          </div>

          <div class="gates-section">
            <h3>Gates</h3>
            ${gatesHtml || '<p style="font-size:12px; color:#4C6A70;">No gates added.</p>'}
            <button class="btn-orange" style="margin-top:8px;" onclick="app.addGate()">+ Add Gate</button>
          </div>
        `;
      },

      // ‚îÄ‚îÄ View switching ‚îÄ‚îÄ
      currentView: 'profile',

      switchView(view) {
        this.currentView = view;
        const tabs = document.querySelectorAll('.view-tab');
        tabs[0].classList.toggle('active', view === 'profile');
        tabs[1].classList.toggle('active', view === '3d');
        document.getElementById('profileViewContainer').style.display = view === 'profile' ? '' : 'none';
        document.getElementById('threeDPlaceholder').style.display = view === '3d' ? '' : 'none';
      },

      // ‚îÄ‚îÄ Profile View: pan/zoom state ‚îÄ‚îÄ
      profilePan: { x: 0, y: 0 },
      profileZoom: 1,
      _profileDrag: null,
      _profileHitRegions: [],
      _profileHover: null,
      highlightedPanelIdx: null,

      // ‚îÄ‚îÄ Soil profile handle dragging state (retaining handles ‚Äî per-panel, orange) ‚îÄ‚îÄ
      _soilHandlePositions: [],    // [{x, y, postIdx}] world coords of each handle
      _soilHandleDrag: null,       // {postIdx, startY, startRetLeft, startRetRight} when dragging
      _soilHandleHover: -1,        // index of hovered handle, -1 if none
      _soilHandleProximity: false,  // true when mouse is near ground line
      _soilGroundOffsets: [],       // cached ground offsets in mm for handle drag calculations

      // ‚îÄ‚îÄ Slope line handle state (ground slope ‚Äî earth brown, 2 endpoints + midpoints) ‚îÄ‚îÄ
      _slopeHandlePositions: [],   // [{x, y, slopeIdx}] world coords of slope handles
      _slopeHandleDrag: null,      // {slopeIdx, startWorldY} when dragging
      _slopeHandleHover: -1,       // index of hovered slope handle
      _slopeHandleProximity: false, // true when mouse is near slope line

      // Select a panel (from table click or canvas click)
      selectPanel(idx) {
        this.highlightedPanelIdx = (this.highlightedPanelIdx === idx) ? null : idx;
        this.renderProfileView();
        // Update table row highlights without full re-render
        const rows = document.querySelectorAll('.panel-table tbody tr[data-panel-idx]');
        rows.forEach(row => {
          const ri = parseInt(row.getAttribute('data-panel-idx'));
          row.classList.toggle('panel-row-highlight', ri === this.highlightedPanelIdx);
        });
        // Scroll the selected row into view
        if (this.highlightedPanelIdx !== null) {
          const sel = document.querySelector(`.panel-table tbody tr[data-panel-idx="${this.highlightedPanelIdx}"]`);
          if (sel) sel.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        }
      },

      // Convert screen mouse coords to canvas world coords (accounting for pan/zoom)
      _screenToWorld(clientX, clientY) {
        const container = document.getElementById('profileViewContainer');
        if (!container) return { x: 0, y: 0 };
        const rect = container.getBoundingClientRect();
        const sx = clientX - rect.left;
        const sy = clientY - rect.top;
        const wx = (sx - this.profilePan.x) / this.profileZoom;
        const wy = (sy - this.profilePan.y) / this.profileZoom;
        return { x: wx, y: wy };
      },

      // Hit test: find which region the world coord falls in
      _hitTest(wx, wy) {
        // Test in reverse order so topmost drawn items match first
        for (let i = this._profileHitRegions.length - 1; i >= 0; i--) {
          const r = this._profileHitRegions[i];
          if (r.shape === 'rect') {
            if (wx >= r.x && wx <= r.x + r.w && wy >= r.y && wy <= r.y + r.h) return r;
          } else if (r.shape === 'circle') {
            const dx = wx - r.cx, dy = wy - r.cy;
            if (dx * dx + dy * dy <= r.r * r.r) return r;
          }
        }
        return null;
      },

      // Check if world coords are near a soil handle; returns index or -1
      _hitTestSoilHandle(wx, wy) {
        const isTouchDevice = 'ontouchstart' in window;
        // Handle is drawn at (handleR / zoom) world units; use a generous hit area
        const baseR = isTouchDevice ? 12 : 8;
        const worldR = (baseR + 4) / this.profileZoom; // slightly larger than visual for easy grabbing
        for (let i = 0; i < this._soilHandlePositions.length; i++) {
          const h = this._soilHandlePositions[i];
          const dx = wx - h.x, dy = wy - h.y;
          if (dx * dx + dy * dy <= worldR * worldR) return i;
        }
        return -1;
      },

      // Check if world Y is within proximity of the soil profile line
      _isNearSoilProfile(wx, wy) {
        const proximityPx = 30 / this.profileZoom;
        for (let i = 0; i < this._soilHandlePositions.length; i++) {
          const h = this._soilHandlePositions[i];
          if (Math.abs(wy - h.y) < proximityPx && Math.abs(wx - h.x) < proximityPx * 3) return true;
        }
        return false;
      },

      // Check if world coords are near a slope handle; returns index or -1
      _hitTestSlopeHandle(wx, wy) {
        const isTouchDevice = 'ontouchstart' in window;
        const baseR = 12;
        const worldR = (baseR + 4) / this.profileZoom;
        for (let i = 0; i < this._slopeHandlePositions.length; i++) {
          const h = this._slopeHandlePositions[i];
          const dx = wx - h.x, dy = wy - h.y;
          if (dx * dx + dy * dy <= worldR * worldR) return i;
        }
        return -1;
      },

      // Check if world coords are near the slope line
      _isNearSlopeLine(wx, wy) {
        if (this._slopeHandlePositions.length < 2) return false;
        const proximityPx = 30 / this.profileZoom;
        // Check proximity to the line segments between slope handles
        for (let i = 0; i < this._slopeHandlePositions.length - 1; i++) {
          const a = this._slopeHandlePositions[i];
          const b = this._slopeHandlePositions[i + 1];
          // Check if wx is between a.x and b.x
          if (wx >= Math.min(a.x, b.x) - proximityPx && wx <= Math.max(a.x, b.x) + proximityPx) {
            // Interpolate Y on the line at wx
            const t = (b.x - a.x) !== 0 ? (wx - a.x) / (b.x - a.x) : 0;
            const lineY = a.y + t * (b.y - a.y);
            if (Math.abs(wy - lineY) < proximityPx) return true;
          }
        }
        return false;
      },

      // Apply slope handle drag: update slopePoints Y value
      _applySlopeHandleDrag(slopeIdx, worldY) {
        const run = this.job.runs.find(r => r.id === this.currentRunId);
        if (!run || !run.slopePoints || slopeIdx >= run.slopePoints.length) return;
        const layout = this._soilHandleLayout;
        if (!layout) return;

        const plinthH = 150;
        // Convert worldY to mm offset from groundY (start level)
        // groundY in world coords = the base ground level (y=0 in slope terms)
        const rawMm = (layout.groundY - worldY) / layout.scale;
        // Snap to 150mm increments
        const snapped = Math.round(rawMm / plinthH) * plinthH;
        // First point stays at 0, others can go negative (lower)
        if (slopeIdx === 0) {
          run.slopePoints[slopeIdx].y = 0; // Start point is always the reference
        } else {
          // Range: 0 to -1500mm (can only slope down from start)
          run.slopePoints[slopeIdx].y = Math.max(-1500, Math.min(0, snapped));
        }
        // Recalc slope for the run
        this.calcSlopeForRun(run);
      },

      _showSlopeHandleTooltip(clientX, clientY, slopeIdx) {
        const run = this.job.runs.find(r => r.id === this.currentRunId);
        if (!run || !run.slopePoints) return;
        const container = document.getElementById('profileViewContainer');
        const tooltip = document.getElementById('soilHandleTooltip');
        if (!tooltip || !container) return;

        const pt = run.slopePoints[slopeIdx];
        const dropMm = Math.abs(pt.y);
        const text = dropMm === 0 ? 'Start level (0mm)' : `Drop: ${dropMm}mm`;

        const rect = container.getBoundingClientRect();
        tooltip.textContent = text;
        tooltip.style.display = 'block';
        tooltip.style.background = 'rgba(139,115,85,0.95)';
        tooltip.style.left = (clientX - rect.left + 14) + 'px';
        tooltip.style.top = (clientY - rect.top - 34) + 'px';
      },

      // Apply soil handle drag: calculate new retaining values from handle position
      _applySoilHandleDrag(postIdx, worldY) {
        const run = this.job.runs.find(r => r.id === this.currentRunId);
        if (!run || run.panels.length === 0) return;

        const panelCount = run.panels.length;
        const plinthHeightMm = 150;

        // The handle's worldY maps to the high-side ground level at this post.
        // We need the rendering parameters to convert worldY back to retaining mm.
        // Use cached layout from last render.
        const layout = this._soilHandleLayout;
        if (!layout) return;

        // Convert worldY displacement from the low-side ground to retaining mm
        // handle going UP (smaller worldY) = more retaining
        // handle going DOWN (larger worldY) = less retaining

        // For the left panel (postIdx - 1): retaining = lowSideGndY - worldY in mm
        // For the right panel (postIdx): retaining = lowSideGndY - worldY in mm
        if (postIdx > 0 && postIdx <= panelCount) {
          // Left panel
          const lpIdx = postIdx - 1;
          const lpLowOff = Math.max(layout.groundOffsets[lpIdx], layout.groundOffsets[postIdx]);
          const lpLowGndY = layout.groundY + lpLowOff * layout.scale;
          const rawRetMm = (lpLowGndY - worldY) / layout.scale;
          const snapped = Math.round(rawRetMm / plinthHeightMm) * plinthHeightMm;
          run.panels[lpIdx].retaining = Math.max(0, Math.min(600, snapped));
        }
        if (postIdx >= 0 && postIdx < panelCount) {
          // Right panel
          const rpIdx = postIdx;
          const rpLowOff = Math.max(layout.groundOffsets[rpIdx], layout.groundOffsets[rpIdx + 1]);
          const rpLowGndY = layout.groundY + rpLowOff * layout.scale;
          const rawRetMm = (rpLowGndY - worldY) / layout.scale;
          const snapped = Math.round(rawRetMm / plinthHeightMm) * plinthHeightMm;
          run.panels[rpIdx].retaining = Math.max(0, Math.min(600, snapped));
        }
      },

      // Show the soil handle drag tooltip
      _showSoilHandleTooltip(clientX, clientY, postIdx) {
        const run = this.job.runs.find(r => r.id === this.currentRunId);
        if (!run) return;
        const container = document.getElementById('profileViewContainer');
        const tooltip = document.getElementById('soilHandleTooltip');
        if (!tooltip || !container) return;

        // Find the max retaining of adjacent panels
        const panelCount = run.panels.length;
        let retMm = 0;
        if (postIdx > 0) retMm = Math.max(retMm, run.panels[postIdx - 1].retaining);
        if (postIdx < panelCount) retMm = Math.max(retMm, run.panels[postIdx].retaining);

        const plinths = retMm / 150;
        let text;
        if (retMm === 0) {
          text = '0mm (no retaining)';
        } else {
          text = `+${retMm}mm (${plinths} plinth${plinths !== 1 ? 's' : ''})`;
        }

        const rect = container.getBoundingClientRect();
        tooltip.textContent = text;
        tooltip.style.display = 'block';
        tooltip.style.background = 'rgba(241,90,41,0.92)';
        tooltip.style.left = (clientX - rect.left + 14) + 'px';
        tooltip.style.top = (clientY - rect.top - 34) + 'px';
      },

      _hideSoilHandleTooltip() {
        const tooltip = document.getElementById('soilHandleTooltip');
        if (tooltip) tooltip.style.display = 'none';
      },

      initProfileViewControls() {
        const container = document.getElementById('profileViewContainer');
        if (!container || container._pvBound) return;
        container._pvBound = true;

        const isTouchDevice = 'ontouchstart' in window;

        container.addEventListener('mousedown', (e) => {
          const w = this._screenToWorld(e.clientX, e.clientY);

          // Check slope handles first (ground slope)
          const slopeIdx = this._hitTestSlopeHandle(w.x, w.y);
          if (slopeIdx >= 0) {
            e.preventDefault();
            e.stopPropagation();
            this._slopeHandleDrag = { slopeIdx, startWorldY: w.y, active: true };
            this._slopeHandleHover = slopeIdx;
            container.style.cursor = 'ns-resize';
            this._showSlopeHandleTooltip(e.clientX, e.clientY, slopeIdx);
            return;
          }

          // Check retaining handles (per-panel)
          const handleIdx = this._hitTestSoilHandle(w.x, w.y);
          if (handleIdx >= 0) {
            e.preventDefault();
            e.stopPropagation();
            const run = this.job.runs.find(r => r.id === this.currentRunId);
            if (!run) return;
            this._soilHandleDrag = {
              postIdx: handleIdx,
              startWorldY: w.y,
              active: true
            };
            this._soilHandleHover = handleIdx;
            container.style.cursor = 'ns-resize';
            this._showSoilHandleTooltip(e.clientX, e.clientY, handleIdx);
            return;
          }

          this._profileDrag = { startX: e.clientX, startY: e.clientY, panX: this.profilePan.x, panY: this.profilePan.y, moved: false };
        });

        window.addEventListener('mousemove', (e) => {
          // Slope handle drag in progress
          if (this._slopeHandleDrag && this._slopeHandleDrag.active) {
            const w = this._screenToWorld(e.clientX, e.clientY);
            this._applySlopeHandleDrag(this._slopeHandleDrag.slopeIdx, w.y);
            this._showSlopeHandleTooltip(e.clientX, e.clientY, this._slopeHandleDrag.slopeIdx);
            this.renderProfileView();
            this._syncPanelTableRetaining();
            return;
          }

          // Retaining handle drag in progress
          if (this._soilHandleDrag && this._soilHandleDrag.active) {
            const w = this._screenToWorld(e.clientX, e.clientY);
            this._applySoilHandleDrag(this._soilHandleDrag.postIdx, w.y);
            this._showSoilHandleTooltip(e.clientX, e.clientY, this._soilHandleDrag.postIdx);
            this.renderProfileView();
            // Sync panel table retaining dropdowns without full re-render
            this._syncPanelTableRetaining();
            return;
          }

          // Pan drag in progress
          if (this._profileDrag) {
            const dx = e.clientX - this._profileDrag.startX;
            const dy = e.clientY - this._profileDrag.startY;
            if (Math.abs(dx) > 3 || Math.abs(dy) > 3) this._profileDrag.moved = true;
            this.profilePan.x = this._profileDrag.panX + dx * 0.6;
            this.profilePan.y = this._profileDrag.panY + dy * 0.6;
            this.renderProfileView();
            return;
          }

          // Hover: check slope handles, retaining handles, and hit regions
          const w = this._screenToWorld(e.clientX, e.clientY);

          // Slope handle hover
          const slopeHoverIdx = this._hitTestSlopeHandle(w.x, w.y);
          if (slopeHoverIdx >= 0) {
            this._slopeHandleHover = slopeHoverIdx;
            this._slopeHandleProximity = true;
            container.style.cursor = 'ns-resize';
            this._showSlopeHandleTooltip(e.clientX, e.clientY, slopeHoverIdx);
            if (this._soilHandleHover >= 0) { this._soilHandleHover = -1; }
            if (this._profileHover) { this._profileHover = null; const pvT = document.getElementById('pvTooltip'); if (pvT) pvT.style.display = 'none'; }
            this.renderProfileView();
            return;
          } else if (this._slopeHandleHover >= 0) {
            this._slopeHandleHover = -1;
            this._hideSoilHandleTooltip();
            this.renderProfileView();
          }

          // Retaining handle hover
          const handleIdx = this._hitTestSoilHandle(w.x, w.y);
          const nearSoil = this._isNearSoilProfile(w.x, w.y);

          if (handleIdx >= 0) {
            this._soilHandleHover = handleIdx;
            this._soilHandleProximity = true;
            container.style.cursor = 'ns-resize';
            this._showSoilHandleTooltip(e.clientX, e.clientY, handleIdx);
            if (this._profileHover) {
              this._profileHover = null;
              const pvTooltip = document.getElementById('pvTooltip');
              if (pvTooltip) pvTooltip.style.display = 'none';
            }
            this.renderProfileView();
            return;
          } else if (this._soilHandleHover >= 0) {
            this._soilHandleHover = -1;
            this._hideSoilHandleTooltip();
            this.renderProfileView();
          }

          // Track proximity to slope line and soil line (show/hide handles)
          const nearSlope = this._isNearSlopeLine(w.x, w.y);
          const wasNearSlope = this._slopeHandleProximity;
          this._slopeHandleProximity = nearSlope;
          if (wasNearSlope !== nearSlope) this.renderProfileView();

          const wasNear = this._soilHandleProximity;
          this._soilHandleProximity = nearSoil;
          if (wasNear !== nearSoil) this.renderProfileView();

          // Standard hover hit-testing
          const hit = this._hitTest(w.x, w.y);
          const tooltip = document.getElementById('pvTooltip');
          if (hit) {
            this._profileHover = hit;
            if (tooltip) {
              const rect = container.getBoundingClientRect();
              tooltip.textContent = hit.label;
              tooltip.style.display = 'block';
              tooltip.style.left = (e.clientX - rect.left + 12) + 'px';
              tooltip.style.top = (e.clientY - rect.top - 28) + 'px';
            }
            container.style.cursor = 'pointer';
            this.renderProfileView();
          } else if (this._profileHover) {
            this._profileHover = null;
            if (tooltip) tooltip.style.display = 'none';
            if (!nearSoil) container.style.cursor = 'grab';
            this.renderProfileView();
          } else if (!nearSoil) {
            container.style.cursor = 'grab';
          }
        });

        window.addEventListener('mouseup', (e) => {
          if (this._slopeHandleDrag && this._slopeHandleDrag.active) {
            // Finish slope handle drag ‚Äî save and do full re-render
            this._slopeHandleDrag = null;
            this._hideSoilHandleTooltip();
            container.style.cursor = 'grab';
            this.save();
            this.render();
            return;
          }
          if (this._soilHandleDrag && this._soilHandleDrag.active) {
            // Finish retaining handle drag ‚Äî save and do full re-render
            this._soilHandleDrag = null;
            this._hideSoilHandleTooltip();
            container.style.cursor = 'grab';
            this.save();
            this.render();
            return;
          }
          if (this._profileDrag && !this._profileDrag.moved) {
            // Click ‚Äî check for panel number circle hit
            const w = this._screenToWorld(e.clientX, e.clientY);
            const hit = this._hitTest(w.x, w.y);
            if (hit && hit.type === 'circle') {
              this.selectPanel(hit.panelIdx);
            }
          }
          this._profileDrag = null;
        });

        // Double-click: add/remove slope midpoints
        container.addEventListener('dblclick', (e) => {
          const run = this.job.runs.find(r => r.id === this.currentRunId);
          if (!run || !run.slopePoints) return;
          const w = this._screenToWorld(e.clientX, e.clientY);

          // Check if double-clicking an existing midpoint (not endpoints)
          const slopeIdx = this._hitTestSlopeHandle(w.x, w.y);
          if (slopeIdx > 0 && slopeIdx < run.slopePoints.length - 1) {
            // Remove this midpoint
            run.slopePoints.splice(slopeIdx, 1);
            this.calcSlopeForRun(run);
            this.save();
            this.render();
            return;
          }

          // Check if double-clicking near the slope line (to add midpoint)
          if (this._isNearSlopeLine(w.x, w.y)) {
            // Max 3 midpoints (5 total points including endpoints)
            if (run.slopePoints.length >= 5) return;

            const layout = this._soilHandleLayout;
            if (!layout) return;

            // Convert world X to fraction along the run
            const totalFenceW = (layout.panelWidthMm * run.panels.length + layout.postWidthMm * (run.panels.length + 1)) * layout.scale;
            const frac = (w.x - layout.originX) / totalFenceW;
            const clampedFrac = Math.max(0.05, Math.min(0.95, frac));

            // Interpolate Y at this fraction from existing slope
            const interpY = this.interpolateSlope(run.slopePoints, clampedFrac);

            // Insert the new point in sorted order
            const newPoint = { x: clampedFrac, y: interpY };
            run.slopePoints.push(newPoint);
            run.slopePoints.sort((a, b) => a.x - b.x);

            this.calcSlopeForRun(run);
            this.save();
            this.render();
          }
        });

        // Touch support for slope + retaining handles
        container.addEventListener('touchstart', (e) => {
          if (e.touches.length !== 1) return;
          const touch = e.touches[0];
          const w = this._screenToWorld(touch.clientX, touch.clientY);

          // Slope handles first
          const slopeIdx = this._hitTestSlopeHandle(w.x, w.y);
          if (slopeIdx >= 0) {
            e.preventDefault();
            this._slopeHandleDrag = { slopeIdx, startWorldY: w.y, active: true, isTouch: true };
            this._slopeHandleHover = slopeIdx;
            this._showSlopeHandleTooltip(touch.clientX, touch.clientY, slopeIdx);
            this.renderProfileView();
            return;
          }

          // Retaining handles
          const handleIdx = this._hitTestSoilHandle(w.x, w.y);
          if (handleIdx >= 0) {
            e.preventDefault();
            this._soilHandleDrag = { postIdx: handleIdx, startWorldY: w.y, active: true, isTouch: true };
            this._soilHandleHover = handleIdx;
            this._showSoilHandleTooltip(touch.clientX, touch.clientY, handleIdx);
            this.renderProfileView();
          }
        }, { passive: false });

        container.addEventListener('touchmove', (e) => {
          if (this._slopeHandleDrag && this._slopeHandleDrag.active && this._slopeHandleDrag.isTouch) {
            e.preventDefault();
            const touch = e.touches[0];
            const w = this._screenToWorld(touch.clientX, touch.clientY);
            this._applySlopeHandleDrag(this._slopeHandleDrag.slopeIdx, w.y);
            this._showSlopeHandleTooltip(touch.clientX, touch.clientY, this._slopeHandleDrag.slopeIdx);
            this.renderProfileView();
            this._syncPanelTableRetaining();
            return;
          }
          if (this._soilHandleDrag && this._soilHandleDrag.active && this._soilHandleDrag.isTouch) {
            e.preventDefault();
            const touch = e.touches[0];
            const w = this._screenToWorld(touch.clientX, touch.clientY);
            this._applySoilHandleDrag(this._soilHandleDrag.postIdx, w.y);
            this._showSoilHandleTooltip(touch.clientX, touch.clientY, this._soilHandleDrag.postIdx);
            this.renderProfileView();
            this._syncPanelTableRetaining();
          }
        }, { passive: false });

        container.addEventListener('touchend', (e) => {
          if (this._slopeHandleDrag && this._slopeHandleDrag.active && this._slopeHandleDrag.isTouch) {
            this._slopeHandleDrag = null;
            this._hideSoilHandleTooltip();
            this.save();
            this.render();
            return;
          }
          if (this._soilHandleDrag && this._soilHandleDrag.active && this._soilHandleDrag.isTouch) {
            this._soilHandleDrag = null;
            this._hideSoilHandleTooltip();
            this.save();
            this.render();
          }
        });

        container.addEventListener('wheel', (e) => {
          e.preventDefault();
          const delta = e.deltaY > 0 ? 0.95 : 1.05;
          const rect = container.getBoundingClientRect();
          const mx = e.clientX - rect.left;
          const my = e.clientY - rect.top;
          this.profilePan.x = mx - (mx - this.profilePan.x) * delta;
          this.profilePan.y = my - (my - this.profilePan.y) * delta;
          this.profileZoom *= delta;
          this.profileZoom = Math.max(0.5, Math.min(5, this.profileZoom));
          this.renderProfileView();
        }, { passive: false });
      },

      // Sync panel table retaining dropdowns to match current panel data (no full re-render)
      _syncPanelTableRetaining() {
        const run = this.job.runs.find(r => r.id === this.currentRunId);
        if (!run) return;
        const dragIdx = this._soilHandleDrag ? this._soilHandleDrag.postIdx : -1;
        const rows = document.querySelectorAll('.panel-table tbody tr[data-panel-idx]');
        rows.forEach(row => {
          const idx = parseInt(row.getAttribute('data-panel-idx'));
          if (idx >= 0 && idx < run.panels.length) {
            const sel = row.querySelector('.col-ret select');
            if (sel && parseInt(sel.value) !== run.panels[idx].retaining) {
              sel.value = run.panels[idx].retaining;
            }
            // Update plinths display
            const plTd = row.querySelector('.col-pl');
            if (plTd) {
              const plinths = run.panels[idx].retaining / 150;
              plTd.textContent = plinths >= 3 ? `${plinths}‚Ä†` : `${plinths}`;
            }
            // Update total display
            const totTd = row.querySelector('.col-total');
            if (totTd) {
              const total = run.panels[idx].height + run.panels[idx].retaining;
              totTd.textContent = total;
              totTd.className = 'col-total ' + (total > 1800 ? 'total-elevated' : 'total-standard');
            }
            // Update post display
            const postTd = row.querySelector('.col-post');
            if (postTd) {
              const posts = this.getRunPosts(run);
              const leftPost = posts[idx];
              const rightPost = posts[idx + 1];
              const maxPost = Math.max(leftPost.postSize, rightPost.postSize);
              const anyPatio = leftPost.patio || rightPost.patio;
              postTd.innerHTML = anyPatio ? `<span class="post-patio">${maxPost}‚Ä†</span>` : `${maxPost}`;
            }
            // Highlight adjacent panels during handle drag
            const isAdjacent = (dragIdx === idx || dragIdx === idx + 1);
            row.style.background = isAdjacent ? 'rgba(139,115,85,0.10)' : '';
          }
        });
      },

      // ‚îÄ‚îÄ Profile View: main render ‚îÄ‚îÄ
      // Panel texture image (loaded from file, cached)
      _panelTextureImg: null,
      _panelTextureLoaded: false,

      // Source crop rectangles from textures/panel_harmony_surfmist.png (2816x1536)
      // Posts: left x=327..389 (63px), right x=2426..2489 (64px)
      // Cap rail: y=51..92 (42px high)
      // Sheet: x=390..2425, y=93..1436 (2036w x 1344h)
      // Bottom rail: y=1437..1482 (46px high)
      SRC_SHEET: { sx: 390, sy: 93, sw: 2036, sh: 1344 },
      SRC_CAP:   { sx: 390, sy: 51, sw: 2036, sh: 42 },
      SRC_RAIL:  { sx: 390, sy: 1437, sw: 2036, sh: 46 },

      _loadPanelTexture() {
        const img = new Image();
        img.onload = () => {
          console.log('Panel texture loaded OK:', img.naturalWidth, 'x', img.naturalHeight);
          this._panelTextureImg = img;
          this._panelTextureLoaded = true;
          this.renderProfileView();
        };
        img.onerror = (e) => {
          console.error('Panel texture FAILED to load:', e);
        };
        img.src = 'textures/panel_harmony_surfmist.png';
      },

      // Track the last run ID we auto-fitted, so we re-fit when switching runs
      _lastFittedRunId: null,

      resetProfileView() {
        this.profilePan = { x: 0, y: 0 };
        this.profileZoom = 1;
        this._lastFittedRunId = null; // force re-fit
        this.renderProfileView();
      },

      renderProfileView() {
        const container = document.getElementById('profileViewContainer');
        const canvas = document.getElementById('profileCanvas');
        if (!container || !canvas) return;

        this.initProfileViewControls();

        const cw = container.clientWidth;
        const ch = container.clientHeight;
        if (cw === 0 || ch === 0) return;

        canvas.width = cw;
        canvas.height = ch;
        const ctx = canvas.getContext('2d');

        // Background
        ctx.fillStyle = '#f0f4f8';
        ctx.fillRect(0, 0, cw, ch);

        const run = this.job.runs.find(r => r.id === this.currentRunId);
        if (!run || run.panels.length === 0) {
          ctx.fillStyle = '#4C6A70';
          ctx.font = '18px Helvetica Neue, Helvetica, Arial, sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('No panels ‚Äî add a run and set its length', cw / 2, ch / 2);
          return;
        }

        // ‚îÄ‚îÄ Colour lookup ‚îÄ‚îÄ
        const allColours = [...COLOURS_STOCK, ...COLOURS_SPECIAL];
        const colourEntry = allColours.find(c => c.name === this.job.colour) || { hex: '#BDBFBA' };
        const fenceHex = colourEntry.hex;

        function darkenHex(hex, factor) {
          const r = parseInt(hex.slice(1, 3), 16);
          const g = parseInt(hex.slice(3, 5), 16);
          const b = parseInt(hex.slice(5, 7), 16);
          return `rgb(${Math.round(Math.min(255, r * factor))},${Math.round(Math.min(255, g * factor))},${Math.round(Math.min(255, b * factor))})`;
        }

        // Total retaining per panel (slope plinths + manual retaining)
        function panelTotalRetaining(p) {
          return (p.slopePlinths || 0) * 150 + p.retaining;
        }

        // ‚îÄ‚îÄ Dimensions in mm ‚îÄ‚îÄ
        const panelCount = run.panels.length;
        const postCount = panelCount + 1;
        const panelWidthMm = this.getPanelWidthMm();
        const postWidthMm = 50;
        const patioWidthMm = 120;  // visual only, does not affect layout spacing
        const embedDepthMm = 600;
        const railHeightMm = 25;
        const plinthHeightMm = 150;

        let maxTotalH = 0;
        run.panels.forEach(p => {
          const th = p.height + panelTotalRetaining(p);
          if (th > maxTotalH) maxTotalH = th;
        });

        // ‚îÄ‚îÄ Ground offsets from Step column ‚îÄ‚îÄ
        const groundOffsets = new Array(postCount).fill(0);
        for (let i = 0; i < panelCount; i++) {
          const step = run.panels[i].step || 'level';
          if (step === 'down') groundOffsets[i + 1] = groundOffsets[i] + plinthHeightMm;
          else if (step === 'up') groundOffsets[i + 1] = groundOffsets[i] - plinthHeightMm;
          else groundOffsets[i + 1] = groundOffsets[i];
        }
        const minGndOffset = Math.min(...groundOffsets);
        for (let i = 0; i < groundOffsets.length; i++) groundOffsets[i] -= minGndOffset;
        const maxGndOffset = Math.max(...groundOffsets);

        // Cache ground offsets for soil handle drag calculations (stored as array in mm)
        this._soilGroundOffsets = groundOffsets.slice();

        const posts = this.getRunPosts(run);

        let maxPostAbove = 0;
        posts.forEach(p => {
          const above = p.postSize - embedDepthMm;
          if (above > maxPostAbove) maxPostAbove = above;
        });

        // ‚îÄ‚îÄ Scaling: 90% width, 70% height ‚îÄ‚îÄ
        // Compute max visible extent above groundY (accounting for plinths raising sheets)
        let maxAboveGndYMm = 0;
        run.panels.forEach((p, idx) => {
          const lowOffset = Math.max(groundOffsets[idx], groundOffsets[idx + 1]);
          const panelTopMm = panelTotalRetaining(p) + railHeightMm + p.height + railHeightMm;
          const above = panelTopMm - lowOffset;
          if (above > maxAboveGndYMm) maxAboveGndYMm = above;
        });
        const totalFenceWidthMm = panelCount * panelWidthMm + postCount * postWidthMm;
        const totalAboveMm = maxAboveGndYMm + 50; // small padding above fence top
        const totalBelowMm = maxGndOffset + embedDepthMm + 200;
        const totalVisualHeightMm = totalAboveMm + totalBelowMm + 150;

        const scaleX = (cw * 0.90) / totalFenceWidthMm;
        const scaleY = (ch * 0.70) / totalVisualHeightMm;
        const scale = Math.min(scaleX, scaleY);

        // Auto-fit on first render or when switching runs
        if (this._lastFittedRunId !== run.id) {
          this.profilePan = { x: 0, y: 0 };
          this.profileZoom = 1;
          this._lastFittedRunId = run.id;
        }

        // Pan/zoom transform
        ctx.save();
        ctx.translate(this.profilePan.x, this.profilePan.y);
        ctx.scale(this.profileZoom, this.profileZoom);

        const fencePixelW = totalFenceWidthMm * scale;
        const originX = (cw / this.profileZoom - fencePixelW) / 2;
        const groundY = (ch / this.profileZoom) * 0.55 + totalAboveMm * scale * 0.1;

        // Cache layout for soil handle drag math
        this._soilHandleLayout = { groundY, scale, groundOffsets, originX, postWidthMm, panelWidthMm };

        const railH = railHeightMm * scale;
        const footingWMm = 300;
        const footingHMm = 450;

        // ‚îÄ‚îÄ Run label ‚îÄ‚îÄ
        const labelFontSize = Math.max(11, Math.min(18, 14 * scale * 2.5));
        ctx.fillStyle = '#293C46';
        ctx.font = `700 ${labelFontSize}px Helvetica Neue, Helvetica, Arial, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.fillText(
          `${run.name}  ¬∑  ${panelCount} panels  ¬∑  ${run.length}m`,
          originX + fencePixelW / 2,
          groundY - maxAboveGndYMm * scale - 10
        );

        // ‚îÄ‚îÄ Soil profile (retained earth behind plinths, viewed from LOW side) ‚îÄ‚îÄ
        // Build the high-side ground profile as a path across the full run
        {
          let sx = originX;
          const earthBottomY = groundY + maxGndOffset * scale + embedDepthMm * scale + 50;

          ctx.save();
          ctx.beginPath();
          // Start at bottom-left
          ctx.moveTo(sx, earthBottomY);

          for (let ei = 0; ei <= panelCount; ei++) {
            const postGnd = groundY + groundOffsets[ei] * scale;
            const epanel = ei < panelCount ? run.panels[ei] : null;
            const epw = postWidthMm * scale;
            const epanelW = panelWidthMm * scale;

            // High-side ground at this post = low-side ground of adjacent panel - plinth stack
            // For a post, we use the highest adjacent panel's high-side level
            let highSideAtPost = postGnd; // default: no retaining = ground level
            if (ei > 0) {
              const lp = run.panels[ei - 1];
              const lpLowOff = Math.max(groundOffsets[ei - 1], groundOffsets[ei]);
              const lpLowGndY = groundY + lpLowOff * scale;
              const lpHighSide = lpLowGndY - panelTotalRetaining(lp) * scale;
              highSideAtPost = Math.min(highSideAtPost, lpHighSide);
            }
            if (ei < panelCount) {
              const rp = run.panels[ei];
              const rpLowOff = Math.max(groundOffsets[ei], groundOffsets[ei + 1]);
              const rpLowGndY = groundY + rpLowOff * scale;
              const rpHighSide = rpLowGndY - panelTotalRetaining(rp) * scale;
              highSideAtPost = Math.min(highSideAtPost, rpHighSide);
            }

            if (ei === 0) {
              // First post: line up from bottom to high-side level
              ctx.lineTo(sx, highSideAtPost);
            } else {
              // Step vertically at post junction then across
              ctx.lineTo(sx, highSideAtPost);
            }

            sx += epw; // past post

            if (epanel) {
              // Across the panel at its high-side level
              const pLowOff = Math.max(groundOffsets[ei], groundOffsets[ei + 1]);
              const pLowGndY = groundY + pLowOff * scale;
              const pHighSide = pLowGndY - panelTotalRetaining(epanel) * scale;
              ctx.lineTo(sx, pHighSide); // left edge of panel at high-side
              sx += epanelW;
              ctx.lineTo(sx, pHighSide); // right edge of panel at high-side
            }
          }

          // Close path down to bottom-right and back
          ctx.lineTo(sx, earthBottomY);
          ctx.closePath();

          // Earth fill gradient
          const earthTopY = groundY - maxGndOffset * scale - 200;
          const grdEarth = ctx.createLinearGradient(0, earthTopY, 0, earthBottomY);
          grdEarth.addColorStop(0, '#C4A882');
          grdEarth.addColorStop(1, '#8B7355');
          ctx.fillStyle = grdEarth;
          ctx.fill();
          ctx.restore();

          // Grass strip along the top edge of the earth profile (4px green line)
          ctx.save();
          ctx.lineWidth = 4;
          ctx.strokeStyle = '#5B8C3E';
          ctx.beginPath();
          let gx = originX;
          let firstPoint = true;
          for (let ei = 0; ei <= panelCount; ei++) {
            const postGnd = groundY + groundOffsets[ei] * scale;
            const epw = postWidthMm * scale;
            const epanelW = panelWidthMm * scale;
            const epanel = ei < panelCount ? run.panels[ei] : null;

            let highSideAtPost = postGnd;
            if (ei > 0) {
              const lp = run.panels[ei - 1];
              const lpLowOff = Math.max(groundOffsets[ei - 1], groundOffsets[ei]);
              const lpLowGndY = groundY + lpLowOff * scale;
              highSideAtPost = Math.min(highSideAtPost, lpLowGndY - panelTotalRetaining(lp) * scale);
            }
            if (ei < panelCount) {
              const rp = run.panels[ei];
              const rpLowOff = Math.max(groundOffsets[ei], groundOffsets[ei + 1]);
              const rpLowGndY = groundY + rpLowOff * scale;
              highSideAtPost = Math.min(highSideAtPost, rpLowGndY - panelTotalRetaining(rp) * scale);
            }

            if (firstPoint) {
              ctx.moveTo(gx, highSideAtPost);
              firstPoint = false;
            } else {
              ctx.lineTo(gx, highSideAtPost);
            }

            gx += epw;

            if (epanel) {
              const pLowOff = Math.max(groundOffsets[ei], groundOffsets[ei + 1]);
              const pLowGndY = groundY + pLowOff * scale;
              const pHighSide = pLowGndY - panelTotalRetaining(epanel) * scale;
              ctx.lineTo(gx, pHighSide);
              gx += epanelW;
              ctx.lineTo(gx, pHighSide);
            }
          }
          ctx.stroke();
          ctx.restore();
        }

        // ‚îÄ‚îÄ Draw posts and panels ‚îÄ‚îÄ
        let cursorX = originX;
        const pw = postWidthMm * scale;

        for (let i = 0; i <= panelCount; i++) {
          const panel = i < panelCount ? run.panels[i] : null;
          const gndOff = groundOffsets[i] * scale;
          const postGndY = groundY + gndOff;

          // ‚îÄ‚îÄ POST ‚Äî height clamped to adjacent panel tops ‚îÄ‚îÄ
          const postInfo = posts[i];

          // Find post top Y from adjacent panels' cap rail tops
          let postTopY = postGndY; // default
          const leftPanel = i > 0 ? run.panels[i - 1] : null;
          const rightPanel = i < panelCount ? run.panels[i] : null;
          if (leftPanel) {
            const lpLowOff = Math.max(groundOffsets[i - 1], groundOffsets[i]);
            const lpLowGndY = groundY + lpLowOff * scale;
            const lpCapTopY = lpLowGndY - (panelTotalRetaining(leftPanel) + railHeightMm + leftPanel.height + railHeightMm) * scale;
            postTopY = Math.min(postTopY, lpCapTopY);
          }
          if (rightPanel) {
            const rpLowOff = Math.max(groundOffsets[i], groundOffsets[i + 1]);
            const rpLowGndY = groundY + rpLowOff * scale;
            const rpCapTopY = rpLowGndY - (panelTotalRetaining(rightPanel) + railHeightMm + rightPanel.height + railHeightMm) * scale;
            postTopY = Math.min(postTopY, rpCapTopY);
          }
          const postAboveH = postGndY - postTopY;

          // Patio tube RHS behind the post (wider backing, same height)
          if (postInfo.patio) {
            const patioW = patioWidthMm * scale;
            const patioX = cursorX - (patioW - pw) / 2;
            ctx.fillStyle = fenceHex;
            ctx.fillRect(patioX, postTopY, patioW, postAboveH);
            ctx.strokeStyle = darkenHex(fenceHex, 0.7);
            ctx.lineWidth = 0.5;
            ctx.strokeRect(patioX, postTopY, patioW, postAboveH);
          }

          // Post body ‚Äî fence colour
          ctx.fillStyle = fenceHex;
          ctx.fillRect(cursorX, postTopY, pw, postAboveH);
          ctx.fillStyle = 'rgba(0,0,0,0.2)';
          ctx.fillRect(cursorX, postTopY, 1, postAboveH);
          ctx.fillRect(cursorX + pw - 1, postTopY, 1, postAboveH);
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.fillRect(cursorX + (pw - 1) / 2, postTopY, 1, postAboveH);
          ctx.strokeStyle = darkenHex(fenceHex, 0.7);
          ctx.lineWidth = 0.5;
          ctx.strokeRect(cursorX, postTopY, pw, postAboveH);

          // Underground: faded post extension + concrete footing
          const embedH = embedDepthMm * scale;
          const postCentreX = cursorX + pw / 2;
          ctx.save();
          ctx.globalAlpha = 0.5;
          ctx.fillStyle = fenceHex;
          ctx.fillRect(cursorX, postGndY, pw, embedH);
          ctx.strokeStyle = darkenHex(fenceHex, 0.7);
          ctx.lineWidth = 0.5;
          ctx.strokeRect(cursorX, postGndY, pw, embedH);
          ctx.restore();
          const footingW = footingWMm * scale;
          const footingH = footingHMm * scale;
          const footingX = postCentreX - footingW / 2;
          const footingY = postGndY + embedH - footingH;
          ctx.fillStyle = '#A0A0A0';
          ctx.fillRect(footingX, footingY, footingW, footingH);
          ctx.save();
          ctx.setLineDash([4, 3]);
          ctx.strokeStyle = '#808080';
          ctx.lineWidth = 1;
          ctx.strokeRect(footingX, footingY, footingW, footingH);
          ctx.restore();

          cursorX += pw;

          // ‚îÄ‚îÄ PANEL (correct construction stacking: plinths ‚Üí bottom rail ‚Üí sheets ‚Üí cap rail) ‚îÄ‚îÄ
          if (panel) {
            const panelW = panelWidthMm * scale;
            const sheetH = panel.height * scale;
            const totalRet = panelTotalRetaining(panel);
            const plinths = totalRet / plinthHeightMm;
            const plinthStackH = totalRet * scale;
            const btmRailH = railH;
            const capRailH = railH;

            // Low-side ground (bottom of plinths)
            const lowSideOff = Math.max(groundOffsets[i], groundOffsets[i + 1]);
            const lowSideGndY = groundY + lowSideOff * scale;
            // High-side ground (top of plinths)
            const highSideGndY = lowSideGndY - plinthStackH;

            // Stacking from bottom to top:
            const plinthBottomY = lowSideGndY;
            const btmRailBottomY = highSideGndY;
            const btmRailTopY = btmRailBottomY - btmRailH;
            const sheetBottomY = btmRailTopY;
            const sheetTopY = sheetBottomY - sheetH;
            const capRailTopY = sheetTopY - capRailH;

            // ‚îÄ‚îÄ Plinths (Colorbond steel plinth panels with horizontal ribs) ‚îÄ‚îÄ
            if (plinths > 0) {
              const plinthH = plinthHeightMm * scale;
              for (let pi = 0; pi < plinths; pi++) {
                const py = plinthBottomY - (pi + 1) * plinthH; // stack upward from low-side ground
                ctx.fillStyle = fenceHex;
                ctx.fillRect(cursorX, py, panelW, plinthH);
                const ribCount = 5;
                const ribSpacing = plinthH / (ribCount + 1);
                ctx.fillStyle = 'rgba(0,0,0,0.15)';
                for (let ri = 1; ri <= ribCount; ri++) {
                  ctx.fillRect(cursorX, py + ri * ribSpacing, panelW, 1);
                }
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.fillRect(cursorX, py + plinthH - 1, panelW, 1);
                if (pi < plinths - 1) {
                  ctx.fillStyle = 'rgba(0,0,0,0.25)';
                  ctx.fillRect(cursorX, py, panelW, 1);
                }
              }
              ctx.strokeStyle = darkenHex(fenceHex, 0.7);
              ctx.lineWidth = 0.5;
              ctx.strokeRect(cursorX, highSideGndY, panelW, plinthStackH);
            }

            // ‚îÄ‚îÄ Bottom rail (from image crop) on top of plinths ‚îÄ‚îÄ
            if (this._panelTextureLoaded) {
              const sr = this.SRC_RAIL;
              ctx.drawImage(this._panelTextureImg, sr.sx, sr.sy, sr.sw, sr.sh,
                cursorX, btmRailTopY, panelW, btmRailH);
              ctx.save();
              ctx.globalCompositeOperation = 'multiply';
              ctx.fillStyle = fenceHex;
              ctx.fillRect(cursorX, btmRailTopY, panelW, btmRailH);
              ctx.globalCompositeOperation = 'source-over';
              ctx.restore();
            } else {
              ctx.fillStyle = fenceHex;
              ctx.fillRect(cursorX, btmRailTopY, panelW, btmRailH);
            }
            ctx.strokeStyle = darkenHex(fenceHex, 0.7);
            ctx.lineWidth = 0.5;
            ctx.strokeRect(cursorX, btmRailTopY, panelW, btmRailH);

            // ‚îÄ‚îÄ Sheets (tiled from image crop) on top of bottom rail ‚îÄ‚îÄ
            ctx.save();
            ctx.beginPath();
            ctx.rect(cursorX, sheetTopY, panelW, sheetH);
            ctx.clip();

            if (this._panelTextureLoaded) {
              const ss = this.SRC_SHEET;
              const sheetWidthMm = 762;
              const numSheets = Math.max(1, Math.floor(panelWidthMm / sheetWidthMm));
              const tileW = panelW / numSheets;
              for (let si = 0; si < numSheets; si++) {
                ctx.drawImage(this._panelTextureImg, ss.sx, ss.sy, ss.sw, ss.sh,
                  cursorX + si * tileW, sheetTopY, tileW, sheetH);
              }
              ctx.globalCompositeOperation = 'multiply';
              ctx.fillStyle = fenceHex;
              ctx.fillRect(cursorX, sheetTopY, panelW, sheetH);
              ctx.globalCompositeOperation = 'source-over';
            } else {
              ctx.fillStyle = fenceHex;
              ctx.fillRect(cursorX, sheetTopY, panelW, sheetH);
            }
            ctx.restore();

            ctx.strokeStyle = darkenHex(fenceHex, 0.7);
            ctx.lineWidth = 0.5;
            ctx.strokeRect(cursorX, sheetTopY, panelW, sheetH);

            // ‚îÄ‚îÄ Per-panel capping rail (from image crop) on top of sheets ‚îÄ‚îÄ
            if (this._panelTextureLoaded) {
              const sc = this.SRC_CAP;
              ctx.drawImage(this._panelTextureImg, sc.sx, sc.sy, sc.sw, sc.sh,
                cursorX, capRailTopY, panelW, capRailH);
              ctx.save();
              ctx.globalCompositeOperation = 'multiply';
              ctx.fillStyle = fenceHex;
              ctx.fillRect(cursorX, capRailTopY, panelW, capRailH);
              ctx.globalCompositeOperation = 'source-over';
              ctx.restore();
            } else {
              ctx.fillStyle = fenceHex;
              ctx.fillRect(cursorX, capRailTopY, panelW, capRailH);
            }
            ctx.strokeStyle = darkenHex(fenceHex, 0.7);
            ctx.lineWidth = 0.5;
            ctx.strokeRect(cursorX, capRailTopY, panelW, capRailH);

            // ‚îÄ‚îÄ Panel number (circled) ‚îÄ‚îÄ
            const circleCX = cursorX + panelW / 2;
            const circleCY = sheetTopY + sheetH / 2;
            const circleR = Math.max(9, Math.min(18, 14 * scale));
            ctx.fillStyle = 'rgba(255,255,255,0.88)';
            ctx.beginPath();
            ctx.arc(circleCX, circleCY, circleR, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#293C46';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.fillStyle = '#293C46';
            const numFontSize = Math.max(8, Math.min(14, 11 * scale));
            ctx.font = `700 ${numFontSize}px Helvetica Neue, Helvetica, Arial, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`P${i + 1}`, circleCX, circleCY);

            // ‚îÄ‚îÄ Highlight panel during adjacent soil handle drag ‚îÄ‚îÄ
            if (this._soilHandleDrag && this._soilHandleDrag.active) {
              const dragIdx = this._soilHandleDrag.postIdx;
              // Panel i is adjacent to handles at post i and post i+1
              if (dragIdx === i || dragIdx === i + 1) {
                ctx.save();
                ctx.fillStyle = 'rgba(241,90,41,0.10)';
                ctx.fillRect(cursorX, capRailTopY, panelW, lowSideGndY - capRailTopY);
                ctx.strokeStyle = 'rgba(241,90,41,0.30)';
                ctx.lineWidth = 1.5;
                ctx.strokeRect(cursorX, capRailTopY, panelW, lowSideGndY - capRailTopY);
                ctx.restore();
              }
            }

            cursorX += panelW;
          }
        }

        // ‚îÄ‚îÄ Ground gradient band ‚îÄ‚îÄ
        const groundBandTop = groundY;
        const groundBandH = (ch / this.profileZoom) - groundBandTop + 100;
        if (groundBandH > 0) {
          const grdGround = ctx.createLinearGradient(0, groundBandTop, 0, groundBandTop + groundBandH);
          grdGround.addColorStop(0, 'rgba(74, 222, 128, 0.15)');
          grdGround.addColorStop(0.12, 'rgba(74, 222, 128, 0.06)');
          grdGround.addColorStop(0.4, 'rgba(146,64,14,0.05)');
          grdGround.addColorStop(1, 'rgba(146,64,14,0.1)');
          ctx.fillStyle = grdGround;
          ctx.fillRect(originX - 30, groundBandTop, fencePixelW + 60, groundBandH);
        }

        // ‚îÄ‚îÄ Slope line (natural ground contour) ‚îÄ‚îÄ
        {
          const slopePoints = run.slopePoints || [{ x: 0, y: 0 }, { x: 1, y: 0 }];
          const isTouchDevice = 'ontouchstart' in window;
          const showSlopeHandles = isTouchDevice || this._slopeHandleProximity || (this._slopeHandleDrag && this._slopeHandleDrag.active);
          const slopeHandleR = 12;

          // Map slope points to world coordinates
          this._slopeHandlePositions = [];
          const slopeWorldPoints = slopePoints.map(sp => {
            const wx = originX + sp.x * fencePixelW;
            const wy = groundY - sp.y * scale; // y is in mm, negative = lower, so subtract
            return { x: wx, y: wy };
          });

          // Store handle positions for hit testing
          for (let si = 0; si < slopePoints.length; si++) {
            this._slopeHandlePositions.push({
              x: slopeWorldPoints[si].x,
              y: slopeWorldPoints[si].y,
              slopeIdx: si
            });
          }

          // Draw slope line (2px solid earth brown)
          if (slopeWorldPoints.length >= 2) {
            ctx.save();
            ctx.strokeStyle = '#8B7355';
            ctx.lineWidth = 2 / this.profileZoom;
            ctx.beginPath();
            ctx.moveTo(slopeWorldPoints[0].x, slopeWorldPoints[0].y);
            for (let si = 1; si < slopeWorldPoints.length; si++) {
              ctx.lineTo(slopeWorldPoints[si].x, slopeWorldPoints[si].y);
            }
            ctx.stroke();

            // 4px green grass strip on top of slope line
            ctx.strokeStyle = '#5B8C3E';
            ctx.lineWidth = 4 / this.profileZoom;
            ctx.beginPath();
            ctx.moveTo(slopeWorldPoints[0].x, slopeWorldPoints[0].y);
            for (let si = 1; si < slopeWorldPoints.length; si++) {
              ctx.lineTo(slopeWorldPoints[si].x, slopeWorldPoints[si].y);
            }
            ctx.stroke();
            ctx.restore();
          }

          // Draw slope handles
          if (showSlopeHandles) {
            for (let si = 0; si < slopeWorldPoints.length; si++) {
              const sp = slopeWorldPoints[si];
              const isHovered = this._slopeHandleHover === si;
              const isDragged = this._slopeHandleDrag && this._slopeHandleDrag.active && this._slopeHandleDrag.slopeIdx === si;

              ctx.beginPath();
              ctx.arc(sp.x, sp.y, slopeHandleR / this.profileZoom, 0, Math.PI * 2);
              ctx.fillStyle = isDragged ? '#6B5335' : (isHovered ? '#A0895F' : '#8B7355');
              ctx.fill();
              ctx.strokeStyle = '#FFFFFF';
              ctx.lineWidth = 2 / this.profileZoom;
              ctx.stroke();

              // Guide line when dragging
              if (isDragged) {
                ctx.save();
                ctx.setLineDash([6 / this.profileZoom, 4 / this.profileZoom]);
                ctx.strokeStyle = 'rgba(139,115,85,0.5)';
                ctx.lineWidth = 1 / this.profileZoom;
                ctx.beginPath();
                ctx.moveTo(originX - 20, sp.y);
                ctx.lineTo(originX + fencePixelW + 20, sp.y);
                ctx.stroke();
                ctx.restore();
              }
            }
          }
        }

        // ‚îÄ‚îÄ Retaining draggable handles (per-panel, orange) ‚îÄ‚îÄ
        {
          const isTouchDevice = 'ontouchstart' in window;
          const showHandles = isTouchDevice || this._soilHandleProximity || (this._soilHandleDrag && this._soilHandleDrag.active);
          const handleR = isTouchDevice ? 12 : 8;
          const epw = postWidthMm * scale;
          const epanelW = panelWidthMm * scale;

          // Calculate handle positions (world coords) at each post junction
          this._soilHandlePositions = [];
          let hx = originX;

          for (let hi = 0; hi <= panelCount; hi++) {
            const postGnd = groundY + groundOffsets[hi] * scale;
            // Compute high-side ground at this post (same logic as soil profile path)
            let highSideAtPost = postGnd;
            if (hi > 0) {
              const lp = run.panels[hi - 1];
              const lpLowOff = Math.max(groundOffsets[hi - 1], groundOffsets[hi]);
              const lpLowGndY = groundY + lpLowOff * scale;
              highSideAtPost = Math.min(highSideAtPost, lpLowGndY - panelTotalRetaining(lp) * scale);
            }
            if (hi < panelCount) {
              const rp = run.panels[hi];
              const rpLowOff = Math.max(groundOffsets[hi], groundOffsets[hi + 1]);
              const rpLowGndY = groundY + rpLowOff * scale;
              highSideAtPost = Math.min(highSideAtPost, rpLowGndY - panelTotalRetaining(rp) * scale);
            }

            // Handle X = centre of the post
            const handleX = hx + epw / 2;
            const handleY = highSideAtPost;

            this._soilHandlePositions.push({ x: handleX, y: handleY, postIdx: hi });

            // Draw handle if visible
            if (showHandles) {
              const isHovered = this._soilHandleHover === hi;
              const isDragged = this._soilHandleDrag && this._soilHandleDrag.active && this._soilHandleDrag.postIdx === hi;

              ctx.beginPath();
              ctx.arc(handleX, handleY, handleR / this.profileZoom, 0, Math.PI * 2);
              ctx.fillStyle = isDragged ? '#C44520' : (isHovered ? '#F47A52' : '#F15A29');
              ctx.fill();
              ctx.strokeStyle = '#FFFFFF';
              ctx.lineWidth = 2 / this.profileZoom;
              ctx.stroke();

              // If dragging this handle, draw a horizontal guide line
              if (isDragged) {
                ctx.save();
                ctx.setLineDash([6 / this.profileZoom, 4 / this.profileZoom]);
                ctx.strokeStyle = 'rgba(241,90,41,0.4)';
                ctx.lineWidth = 1 / this.profileZoom;
                ctx.beginPath();
                ctx.moveTo(originX - 20, handleY);
                ctx.lineTo(originX + fencePixelW + 20, handleY);
                ctx.stroke();
                ctx.restore();
              }
            }

            // Advance cursor: past this post + next panel
            hx += epw;
            if (hi < panelCount) hx += epanelW;
          }
        }

        ctx.restore();
      },

      generateOutputs() {
        alert('Output generation not yet implemented.');
      },

      // ‚îÄ‚îÄ LocalStorage ‚îÄ‚îÄ
      save() {
        localStorage.setItem('fenceJob', JSON.stringify(this.job));
        const ind = document.getElementById('savedIndicator');
        if (ind) {
          ind.textContent = 'Saved';
          ind.style.opacity = '1';
          setTimeout(() => { ind.style.opacity = '0.7'; }, 1000);
        }
      },

      loadFromStorage() {
        const saved = localStorage.getItem('fenceJob');
        if (saved) {
          try {
            this.job = JSON.parse(saved);
            // Migration: ensure new fields exist
            if (!this.job.gates) this.job.gates = [];
            this.job.runs.forEach(run => {
              if (run.sheetHeight === undefined) run.sheetHeight = run.defaultHeight || 1800;
              if (run.extension === undefined || run.extension === null) run.extension = 'none';
              if (!run.slopePoints) run.slopePoints = [{ x: 0, y: 0 }, { x: 1, y: 0 }];
              run.panels.forEach(p => {
                if (p.step === undefined) p.step = p.ground || 'level';
                if (p.slopePlinths === undefined) p.slopePlinths = 0;
                // Clamp any legacy 750mm retaining to 600mm max
                if (p.retaining > 600) p.retaining = 600;
              });
            });
            if (this.job.runs.length > 0 && !this.currentRunId) {
              this.currentRunId = this.job.runs[0].id;
            }
          } catch (e) {
            this.job = null;
          }
        }
      }
    };

    window.addEventListener('DOMContentLoaded', () => app.init());
  </script>
</body>
</html>
